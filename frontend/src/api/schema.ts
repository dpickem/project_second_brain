/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health Check
         * @description Basic health check.
         *
         *     Returns a simple status response indicating the API is running.
         */
        get: operations["health_check_api_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/health/detailed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Detailed Health Check
         * @description Detailed health check with dependency status.
         *
         *     Checks connectivity to:
         *     - PostgreSQL database
         *     - Redis cache
         *     - Neo4j graph database
         *     - Obsidian vault accessibility (with note count)
         *     - Vault watcher and sync services
         *     - Celery workers
         */
        get: operations["detailed_health_check_api_health_detailed_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/health/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Readiness Check
         * @description Readiness probe for orchestration systems.
         *
         *     Returns 200 only if the service is ready to accept traffic.
         *     Checks critical dependencies (database, Redis).
         *
         *     Used by: Docker health checks, load balancers, Kubernetes, etc.
         */
        get: operations["readiness_check_api_health_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/capture/text": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Capture Text
         * @description Quick text capture for ideas, notes, and thoughts.
         *
         *     Immediately queues content for processing and returns.
         *     Processing includes: LLM tagging, Obsidian note creation, knowledge graph.
         *
         *     Args:
         *         background_tasks: FastAPI background tasks handler for async processing.
         *         content: The text content to capture (required).
         *         title: Optional title for the note. If not provided, generated from content.
         *         tags: Optional comma-separated list of tags (e.g., "idea,work,urgent").
         *
         *     Returns:
         *         dict: Response containing status, content ID, title, and processing message.
         */
        post: operations["capture_text_api_capture_text_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/capture/url": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Capture Url
         * @description Capture a URL for later processing.
         *
         *     Fetches page title immediately, then queues full content
         *     extraction for background processing.
         *
         *     Args:
         *         background_tasks: FastAPI background tasks handler for async processing.
         *         url: The URL to capture (must start with http:// or https://).
         *         notes: Optional notes about why this URL was saved or key takeaways.
         *         tags: Optional comma-separated list of tags (e.g., "article,ai,research").
         *
         *     Returns:
         *         dict: Response containing status, content ID, title, URL, and processing message.
         *
         *     Raises:
         *         HTTPException: 400 if URL doesn't start with http:// or https://.
         */
        post: operations["capture_url_api_capture_url_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/capture/photo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Capture Photo
         * @description Capture a photo for OCR processing.
         *
         *     Supports book pages, whiteboards, documents, and general photos.
         *     Uses Vision LLM for text and handwriting extraction.
         *
         *     Args:
         *         background_tasks: FastAPI background tasks handler for async processing.
         *         file: The image file to process (JPEG, PNG, etc.).
         *         capture_type: Type of photo being captured. Options:
         *             - "book_page": Page from a physical book with potential margin notes.
         *             - "whiteboard": Whiteboard or blackboard photo.
         *             - "document": Printed document or form.
         *             - "general": General photo with text (default).
         *         notes: Optional notes or context about the photo.
         *         book_title: Book title if capture_type is "book_page".
         *
         *     Returns:
         *         dict: Response containing status, content ID, file path, capture type,
         *               and processing message.
         *
         *     Raises:
         *         HTTPException: 400 if file is not an image.
         */
        post: operations["capture_photo_api_capture_photo_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/capture/voice": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Capture Voice
         * @description Capture a voice memo for transcription.
         *
         *     Uses Whisper for transcription and optionally expands the
         *     raw transcript into a well-structured note.
         *
         *     High-priority processing for quick turnaround.
         *
         *     Args:
         *         background_tasks: FastAPI background tasks handler for async processing.
         *         file: Audio file to transcribe. Supported formats: MP3, MP4, WAV, WebM,
         *               M4A, OGG, FLAC.
         *         expand: If True (default), uses LLM to expand raw transcript into a
         *                 structured, well-formatted note. If False, keeps raw transcript.
         *
         *     Returns:
         *         dict: Response containing status, content ID, file path, and processing
         *               message indicating high-priority queue.
         *
         *     Raises:
         *         HTTPException: 400 if audio format is not supported.
         */
        post: operations["capture_voice_api_capture_voice_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/capture/pdf": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Capture Pdf
         * @description Upload a PDF for processing.
         *
         *     Extracts text, digital highlights/comments, and optionally
         *     handwritten annotations using Vision LLM.
         *
         *     Args:
         *         background_tasks: FastAPI background tasks handler for async processing.
         *         file: The PDF file to process.
         *         content_type_hint: Optional hint about the PDF content type to optimize
         *                           processing. Options:
         *             - "paper": Academic paper with citations and abstract.
         *             - "article": Web article or blog post.
         *             - "book": Book chapter or full book.
         *             - "general": General document (default).
         *         detect_handwriting: If True (default), uses Vision LLM to detect and
         *                            extract handwritten annotations in margins.
         *
         *     Returns:
         *         dict: Response containing status, content ID, file path, filename,
         *               and processing message.
         *
         *     Raises:
         *         HTTPException: 400 if file is not a PDF.
         */
        post: operations["capture_pdf_api_capture_pdf_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/capture/book": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Capture Book
         * @description Capture multiple book page photos as a single book.
         *
         *     Uploads all images and processes them together using BookOCRPipeline.
         *     Pages are processed in PARALLEL for faster results.
         *
         *     Note: This endpoint requires individual file uploads rather than a directory path
         *     because the backend runs inside Docker and doesn't have access to the host
         *     filesystem. Files are uploaded via multipart form data and saved to the
         *     container's /uploads volume.
         *
         *     The pipeline:
         *     - Extracts page numbers via OCR (doesn't assume order from upload)
         *     - Detects chapters from running headers
         *     - Extracts printed text and handwritten margin notes
         *     - Aggregates all pages into a single Obsidian note
         *
         *     Performance:
         *     - 10 pages @ concurrency 5: ~30 seconds
         *     - 50 pages @ concurrency 10: ~75 seconds
         *     - 100 pages @ concurrency 10: ~150 seconds
         *
         *     Best for: Capturing highlights and margin notes from physical books.
         *
         *     Args:
         *         background_tasks: FastAPI background tasks handler for async processing.
         *         files: List of image files (JPG, PNG, HEIC, WebP, TIFF) representing
         *                book pages. Order doesn't matter; pages are sorted by detected
         *                page numbers during OCR processing.
         *         title: Optional book title. If not provided, the pipeline will attempt
         *                to infer it from page headers or generate a timestamped title.
         *         authors: Optional comma-separated list of author names
         *                  (e.g., "Cal Newport, James Clear").
         *         isbn: Optional ISBN for metadata lookup and book identification.
         *         notes: Optional notes about the book or why it was captured.
         *
         *     Returns:
         *         dict: Response containing status, content ID, title, page count,
         *               file paths, and processing message.
         *
         *     Raises:
         *         HTTPException: 400 if no files provided or if any file is not a
         *                       supported image format.
         */
        post: operations["capture_book_api_capture_book_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/raindrop/sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Raindrop Sync
         * @description Trigger Raindrop.io sync.
         *
         *     Syncs bookmarks created since the specified number of days ago.
         *
         *     Args:
         *         background_tasks: FastAPI background task manager
         *         request: Sync configuration with since_days, collection_id, and limit
         *
         *     Returns:
         *         Dict with sync status and parameters
         */
        post: operations["trigger_raindrop_sync_api_ingestion_raindrop_sync_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/github/sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Github Sync
         * @description Sync GitHub starred repositories.
         *
         *     Imports recently starred repos up to the specified limit.
         *
         *     Args:
         *         background_tasks: FastAPI background task manager
         *         request: Sync configuration with limit
         *
         *     Returns:
         *         Dict with sync status and parameters
         */
        post: operations["trigger_github_sync_api_ingestion_github_sync_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/status/{content_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Processing Status
         * @description Get processing status for a content item.
         *
         *     Returns current status and any error messages.
         *
         *     Args:
         *         content_id: UUID of the content item to check
         *
         *     Returns:
         *         Dict with id, title, status, error, source_type, created_at, obsidian_path
         *
         *     Raises:
         *         HTTPException: 404 if content not found
         */
        get: operations["get_processing_status_api_ingestion_status__content_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/queue/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Queue Statistics
         * @description Get processing queue statistics.
         *
         *     Returns counts of active, queued, and scheduled tasks.
         *
         *     Returns:
         *         Dict with status and queue statistics (active, queued, scheduled counts)
         */
        get: operations["get_queue_statistics_api_ingestion_queue_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/scheduled": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Scheduled Jobs
         * @description List all scheduled sync jobs.
         *
         *     Returns job IDs, names, and next run times.
         *
         *     Returns:
         *         Dict with jobs list and count
         */
        get: operations["list_scheduled_jobs_api_ingestion_scheduled_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/scheduled/{job_id}/trigger": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Scheduled Job
         * @description Manually trigger a scheduled job immediately.
         *
         *     Useful for testing or forcing an immediate sync.
         *
         *     Args:
         *         job_id: ID of the scheduled job to trigger
         *
         *     Returns:
         *         Dict with trigger status and job_id
         *
         *     Raises:
         *         HTTPException: 404 if job not found
         */
        post: operations["trigger_scheduled_job_api_ingestion_scheduled__job_id__trigger_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/pending": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Pending Content
         * @description List content items pending processing.
         *
         *     Useful for monitoring the processing backlog.
         *
         *     Args:
         *         limit: Maximum number of items to return (default: 20)
         *
         *     Returns:
         *         Dict with count and list of pending content items
         */
        get: operations["list_pending_content_api_ingestion_pending_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/ingestion/taxonomy/sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Sync Taxonomy
         * @description Sync tag taxonomy from YAML to database.
         *
         *     Creates any tags from the YAML taxonomy that don't exist in the database.
         *     This is also run automatically daily at 4 AM UTC.
         *
         *     Returns:
         *         Dict with sync status and count of tags created
         */
        post: operations["sync_taxonomy_api_ingestion_taxonomy_sync_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/processing/trigger": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Trigger Processing
         * @description Trigger LLM processing for a content item.
         *
         *     Processing runs asynchronously in the background. Use the status
         *     endpoint to check progress.
         *
         *     Args:
         *         request: Processing request with content_id and optional config
         *
         *     Returns:
         *         TriggerProcessingResponse with queued status
         */
        post: operations["trigger_processing_api_processing_trigger_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/processing/status/{content_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Processing Status
         * @description Get processing status for a content item.
         *
         *     Returns the current status and metadata about the most recent
         *     processing run.
         *
         *     Args:
         *         content_id: UUID of the content
         *
         *     Returns:
         *         ProcessingStatusResponse with status and timing info
         */
        get: operations["get_processing_status_api_processing_status__content_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/processing/result/{content_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Processing Result
         * @description Get full processing result for a content item.
         *
         *     Returns the complete processing result including analysis,
         *     summaries, concepts, tags, connections, and more.
         *
         *     Args:
         *         content_id: UUID of the content
         *
         *     Returns:
         *         ProcessingResultResponse with all processing outputs
         *
         *     Raises:
         *         HTTPException 404: If content or processing result not found
         */
        get: operations["get_processing_result_api_processing_result__content_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/processing/pending": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pending Content
         * @description Get all content items pending processing.
         *
         *     Returns content that has been ingested but not yet processed,
         *     optionally including items that failed processing.
         *
         *     Args:
         *         limit: Maximum number of items to return (default 100)
         *         include_failed: Whether to include failed items (default False)
         *
         *     Returns:
         *         PendingContentResponse with list of pending items
         */
        get: operations["get_pending_content_api_processing_pending_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/processing/reprocess": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reprocess Content
         * @description Reprocess specific stages for existing content.
         *
         *     Useful when prompts are updated or specific stages need to be re-run.
         *
         *     Args:
         *         content_id: UUID of content to reprocess
         *         stages: List of stages to run (e.g., [ProcessingStage.SUMMARIZATION])
         *
         *     Returns:
         *         Status indicating reprocessing was queued
         */
        post: operations["reprocess_content_api_processing_reprocess_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Vault Status
         * @description Get vault status and statistics.
         */
        get: operations["get_vault_status_api_vault_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/ensure-structure": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ensure Vault Structure
         * @description Ensure vault folder structure exists (idempotent).
         *
         *     Creates any missing folders. Safe to call multiple times.
         */
        post: operations["ensure_vault_structure_api_vault_ensure_structure_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/indices/regenerate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Regenerate Indices
         * @description Regenerate all folder indices.
         */
        post: operations["regenerate_indices_api_vault_indices_regenerate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/daily": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Daily Note
         * @description Create a daily note.
         */
        post: operations["create_daily_note_api_vault_daily_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/daily/inbox": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Inbox Item
         * @description Add an item to today's daily note inbox.
         */
        post: operations["add_inbox_item_api_vault_daily_inbox_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Sync Vault To Neo4J
         * @description Sync entire vault to Neo4j (runs in background).
         */
        post: operations["sync_vault_to_neo4j_api_vault_sync_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Folders
         * @description List all content type folders in the vault.
         */
        get: operations["list_folders_api_vault_folders_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/watcher/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Vault Watcher Status
         * @description Get the current status of the vault file watcher.
         */
        get: operations["get_vault_watcher_status_api_vault_watcher_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/sync/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Vault Sync Status
         * @description Get the current status of vault-to-Neo4j sync.
         *
         *     Returns:
         *         - is_running: Whether a sync is currently in progress
         *         - sync_type: Type of sync ("full" or "reconciliation")
         *         - progress: Current progress (total, processed, synced, failed, percent)
         *         - last_result: Result of the last completed sync
         *         - last_completed_at: When the last sync completed
         *         - last_error: Error message if the last sync failed
         */
        get: operations["get_vault_sync_status_api_vault_sync_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Notes
         * @description List notes in the vault with filtering and pagination.
         *
         *     Scans the vault for markdown files and returns metadata.
         *     Supports filtering by folder, search term, tag, and content type.
         */
        get: operations["list_notes_api_vault_notes_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/vault/notes/{note_path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note
         * @description Get the full content of a specific note.
         *
         *     Args:
         *         note_path: Relative path to the note from vault root (e.g., "papers/my-paper.md")
         *
         *     Returns:
         *         Full note content with parsed frontmatter.
         */
        get: operations["get_note_api_vault_notes__note_path__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knowledge/graph": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Graph Visualization
         * @description Get graph data for visualization.
         *
         *     Returns nodes and edges in D3-compatible format for force-directed graphs.
         *
         *     Args:
         *         center_id: Optional node ID to center the graph on
         *         node_types: Comma-separated list of node types to include
         *         depth: How many hops from center to traverse (only used with center_id)
         *         limit: Maximum number of nodes to return
         *
         *     Returns:
         *         GraphResponse with nodes, edges, and metadata
         */
        get: operations["get_graph_visualization_api_knowledge_graph_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knowledge/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Graph Stats
         * @description Get summary statistics for the knowledge graph.
         *
         *     Returns:
         *         GraphStats with node and relationship counts
         */
        get: operations["get_graph_stats_api_knowledge_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knowledge/node/{node_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Node Details
         * @description Get detailed information about a specific node.
         *
         *     Args:
         *         node_id: The node's unique identifier
         *
         *     Returns:
         *         NodeDetails with full node information
         *
         *     Raises:
         *         HTTPException 404: If node not found
         */
        get: operations["get_node_details_api_knowledge_node__node_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knowledge/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Knowledge Graph Health
         * @description Check Neo4j connection health.
         *
         *     Returns:
         *         Health status dict with neo4j_connected boolean
         */
        get: operations["knowledge_graph_health_api_knowledge_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knowledge/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search Knowledge
         * @description Semantic search across knowledge base.
         *
         *     Uses embeddings to find semantically similar content when available,
         *     otherwise falls back to keyword/fulltext matching. Searches across
         *     Content, Concepts, and Notes.
         *
         *     Args:
         *         request: Search query and filters
         *
         *     Returns:
         *         SearchResponse with ranked results
         */
        post: operations["search_knowledge_api_knowledge_search_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knowledge/connections/{node_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Connections
         * @description Get connections for a specific node.
         *
         *     Returns incoming and outgoing relationships, optionally filtered by direction.
         *
         *     Args:
         *         node_id: The node to get connections for
         *         direction: incoming, outgoing, or both
         *         limit: Maximum connections per direction
         *
         *     Returns:
         *         ConnectionsResponse with incoming and outgoing lists
         */
        get: operations["get_connections_api_knowledge_connections__node_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/knowledge/topics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Topic Hierarchy
         * @description Get hierarchical topic structure.
         *
         *     Topics are organized in a tree based on their tag paths:
         *     - ml/
         *       - ml/deep-learning/
         *         - ml/deep-learning/transformers/
         *
         *     Args:
         *         min_content: Filter out topics with fewer items
         *
         *     Returns:
         *         TopicHierarchyResponse with tree structure
         */
        get: operations["get_topic_hierarchy_api_knowledge_topics_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/practice/session": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Session
         * @description Create a new practice session.
         *
         *     Returns a balanced session with:
         *     - 40% due spaced rep cards
         *     - 30% weak spot exercises
         *     - 30% new/interleaved content
         */
        post: operations["create_session_api_practice_session_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/practice/session/{session_id}/end": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * End Session
         * @description End a practice session and get summary statistics.
         */
        post: operations["end_session_api_practice_session__session_id__end_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/practice/exercise/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Exercise
         * @description Generate an adaptive exercise for a topic.
         *
         *     Exercise type and difficulty are selected based on mastery level:
         *     - < 0.3: Worked examples, code completions
         *     - 0.3-0.7: Free recall, implementations
         *     - > 0.7: Applications, teach-back
         */
        post: operations["generate_exercise_api_practice_exercise_generate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/practice/exercises": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Exercises
         * @description List all exercises with optional filtering.
         *
         *     Returns exercises ordered by creation date (newest first).
         */
        get: operations["list_exercises_api_practice_exercises_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/practice/exercise/{exercise_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Exercise
         * @description Get an exercise by ID.
         */
        get: operations["get_exercise_api_practice_exercise__exercise_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/practice/submit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Submit Attempt
         * @description Submit an exercise attempt for evaluation.
         *
         *     Returns detailed feedback including:
         *     - Score (0-1)
         *     - Covered and missing key points
         *     - Misconceptions identified
         *     - LLM-generated feedback
         *     - Solution reveal
         */
        post: operations["submit_attempt_api_practice_submit_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/practice/attempt/{attempt_id}/confidence": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Confidence
         * @description Update confidence rating after viewing feedback.
         */
        patch: operations["update_confidence_api_practice_attempt__attempt_id__confidence_patch"];
        trace?: never;
    };
    "/api/review/cards": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Card
         * @description Create a new spaced repetition card.
         *
         *     Card is created in NEW state with FSRS initial parameters.
         */
        post: operations["create_card_api_review_cards_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/review/cards/{card_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Card
         * @description Get a card by ID.
         */
        get: operations["get_card_api_review_cards__card_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/review/due": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Due Cards
         * @description Get cards due for review.
         *
         *     Returns cards ordered by due date (oldest first) with a review forecast.
         */
        get: operations["get_due_cards_api_review_due_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/review/rate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Rate Card
         * @description Submit a review rating for a card.
         *
         *     FSRS ratings:
         *     - AGAIN (1): Complete failure, reset to learning
         *     - HARD (2): Significant difficulty, shorter interval
         *     - GOOD (3): Correct with effort, normal interval
         *     - EASY (4): Too easy, longer interval
         *
         *     Returns the new scheduling information.
         */
        post: operations["rate_card_api_review_rate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/review/evaluate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Evaluate Card Answer
         * @description Evaluate a typed answer for a card using LLM.
         *
         *     This enables "active recall" mode where users type their answer
         *     instead of just flipping the card. The LLM evaluates the answer
         *     semantically and returns an appropriate FSRS rating.
         *
         *     Use the returned rating with the /rate endpoint to save the review.
         *
         *     Returns:
         *     - rating: FSRS rating (1-4) based on answer quality
         *     - is_correct: True if rating >= 3 (Good or Easy)
         *     - feedback: Explanation of what was correct/incorrect
         *     - expected_answer: The correct answer for comparison
         */
        post: operations["evaluate_card_answer_api_review_evaluate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/review/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Card Stats
         * @description Get card statistics.
         *
         *     Returns counts by state, average stability/difficulty, and due counts.
         */
        get: operations["get_card_stats_api_review_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/review/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Cards
         * @description Generate spaced repetition cards for a topic on-demand.
         *
         *     Uses existing content and LLM to generate flashcards for the specified topic.
         *     Useful when starting a review session for a topic with few or no cards.
         */
        post: operations["generate_cards_api_review_generate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/review/ensure-cards": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ensure Cards For Topic
         * @description Ensure a minimum number of cards exist for a topic.
         *
         *     If fewer than `minimum` cards exist, generates more using LLM.
         *     Returns immediately if enough cards already exist.
         */
        post: operations["ensure_cards_for_topic_api_review_ensure_cards_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/overview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Mastery Overview
         * @description Get overall mastery statistics.
         *
         *     Returns:
         *     - Overall mastery score
         *     - Card counts by state
         *     - Topic masteries
         *     - Practice streak
         */
        get: operations["get_mastery_overview_api_analytics_overview_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/daily": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Daily Stats
         * @description Get daily statistics for the dashboard.
         *
         *     Returns today's learning status including:
         *     - Current streak and risk status
         *     - Due cards count
         *     - Cards reviewed today
         *     - Overall mastery
         *     - Practice time today
         */
        get: operations["get_daily_stats_api_analytics_daily_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/practice-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Practice History
         * @description Get practice history for activity heatmap.
         *
         *     Returns daily practice activity for the specified number of weeks,
         *     suitable for rendering a GitHub-style contribution heatmap.
         */
        get: operations["get_practice_history_api_analytics_practice_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/mastery/{topic}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Topic Mastery
         * @description Get mastery state for a specific topic.
         *
         *     Topic paths use slashes (e.g., "ml/transformers/attention").
         */
        get: operations["get_topic_mastery_api_analytics_mastery__topic__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/weak-spots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Weak Spots
         * @description Get topics identified as weak spots.
         *
         *     Weak spots are topics with:
         *     - Mastery score < 0.6
         *     - At least 3 practice attempts
         *     - Declining trends prioritized
         */
        get: operations["get_weak_spots_api_analytics_weak_spots_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/learning-curve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Learning Curve
         * @description Get learning curve data for visualization.
         *
         *     Returns historical mastery data points for charting progress over time.
         */
        get: operations["get_learning_curve_api_analytics_learning_curve_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/snapshot": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Take Mastery Snapshot
         * @description Manually trigger a mastery snapshot.
         *
         *     This is normally done by a scheduled job at midnight,
         *     but can be triggered manually for testing.
         */
        post: operations["take_mastery_snapshot_api_analytics_snapshot_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/time-investment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Time Investment
         * @description Get time investment breakdown.
         *
         *     Shows how much time has been spent learning,
         *     broken down by topic and activity type.
         *
         *     Args:
         *         period: Time period to analyze (7d, 30d, 90d, 1y, all)
         *         group_by: How to group the data (day, week, month)
         *
         *     Returns:
         *         Time investment summary with trends
         */
        get: operations["get_time_investment_api_analytics_time_investment_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/streak": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Streak Data
         * @description Get practice streak information.
         *
         *     A streak is maintained by practicing at least once per day.
         *     Streaks reset if a day is missed.
         *
         *     Returns:
         *         Current streak, history, and milestones
         */
        get: operations["get_streak_data_api_analytics_streak_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/analytics/time-log": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Log Learning Time
         * @description Log time spent on a learning activity.
         *
         *     Called by frontend to track time investment.
         *     Duration is calculated from started_at and ended_at.
         *
         *     Args:
         *         request: Time log details
         *
         *     Returns:
         *         Created time log record
         */
        post: operations["log_learning_time_api_analytics_time_log_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/chat": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Send Message
         * @description Send a message to the AI assistant and get a response.
         *
         *     Args:
         *         request: Chat request with message and optional conversation_id.
         *         service: Injected assistant service.
         *
         *     Returns:
         *         ChatResponse with conversation_id, response, and sources.
         *
         *     Raises:
         *         HTTPException 404: If specified conversation not found.
         *         HTTPException 500: If chat processing fails.
         */
        post: operations["send_message_api_assistant_chat_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/conversations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Conversations
         * @description Get paginated list of all conversations.
         *
         *     Args:
         *         limit: Maximum conversations to return (1-100).
         *         offset: Number to skip for pagination.
         *         service: Injected assistant service.
         *
         *     Returns:
         *         ConversationListResponse with conversations and total count.
         *
         *     Raises:
         *         HTTPException 500: If retrieval fails.
         */
        get: operations["get_conversations_api_assistant_conversations_get"];
        put?: never;
        post?: never;
        /**
         * Clear All Conversations
         * @description Delete all conversations and messages.
         *
         *     Args:
         *         service: Injected assistant service.
         *
         *     Returns:
         *         DeleteResponse with count of cleared conversations.
         *
         *     Raises:
         *         HTTPException 500: If clearing fails.
         */
        delete: operations["clear_all_conversations_api_assistant_conversations_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/conversations/{conversation_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Conversation
         * @description Get a specific conversation with all its messages.
         *
         *     Args:
         *         conversation_id: Unique conversation identifier.
         *         service: Injected assistant service.
         *
         *     Returns:
         *         ConversationDetail with messages.
         *
         *     Raises:
         *         HTTPException 404: If conversation not found.
         *         HTTPException 500: If retrieval fails.
         */
        get: operations["get_conversation_api_assistant_conversations__conversation_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Conversation
         * @description Delete a conversation and all its messages.
         *
         *     Args:
         *         conversation_id: Unique conversation identifier.
         *         service: Injected assistant service.
         *
         *     Returns:
         *         DeleteResponse with success status.
         *
         *     Raises:
         *         HTTPException 404: If conversation not found.
         *         HTTPException 500: If deletion fails.
         */
        delete: operations["delete_conversation_api_assistant_conversations__conversation_id__delete"];
        options?: never;
        head?: never;
        /**
         * Rename Conversation
         * @description Rename a conversation.
         *
         *     Args:
         *         conversation_id: Unique conversation identifier.
         *         request: Update request with new title.
         *         service: Injected assistant service.
         *
         *     Returns:
         *         ConversationUpdateResponse with updated metadata.
         *
         *     Raises:
         *         HTTPException 404: If conversation not found.
         *         HTTPException 500: If update fails.
         */
        patch: operations["rename_conversation_api_assistant_conversations__conversation_id__patch"];
        trace?: never;
    };
    "/api/assistant/conversations/{conversation_id}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Clear Conversation Messages
         * @description Clear all messages from a conversation.
         *
         *     Args:
         *         conversation_id: Unique conversation identifier.
         *         service: Injected assistant service.
         *
         *     Returns:
         *         DeleteResponse with count of cleared messages.
         *
         *     Raises:
         *         HTTPException 500: If clearing fails.
         */
        delete: operations["clear_conversation_messages_api_assistant_conversations__conversation_id__messages_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/suggestions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Suggestions
         * @description Get AI-generated prompt suggestions based on current knowledge base.
         *
         *     Args:
         *         service: Injected assistant service.
         *
         *     Returns:
         *         SuggestionsResponse with list of suggested prompts.
         *
         *     Raises:
         *         HTTPException 500: If suggestion generation fails.
         */
        get: operations["get_suggestions_api_assistant_suggestions_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Knowledge
         * @description Search knowledge base for content relevant to a query.
         *
         *     Args:
         *         q: Search query string.
         *         service: Injected assistant service.
         *
         *     Returns:
         *         KnowledgeSearchResponse with search results.
         *
         *     Raises:
         *         HTTPException 500: If search fails.
         */
        get: operations["search_knowledge_api_assistant_search_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/recommendations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Recommendations
         * @description Get personalized study recommendations based on learning history.
         *
         *     Args:
         *         service: Injected assistant service.
         *
         *     Returns:
         *         RecommendationsResponse with prioritized study recommendations.
         *
         *     Raises:
         *         HTTPException 500: If recommendation generation fails.
         */
        get: operations["get_recommendations_api_assistant_recommendations_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/quiz": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Quiz
         * @description Generate a quiz on a specific topic.
         *
         *     Args:
         *         request: Quiz parameters (topic_id and question_count).
         *         service: Injected assistant service.
         *
         *     Returns:
         *         QuizResponse with generated questions.
         *
         *     Raises:
         *         HTTPException 500: If quiz generation fails.
         */
        post: operations["generate_quiz_api_assistant_quiz_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/assistant/explain/{concept_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Explain Concept
         * @description Get an AI-generated explanation of a concept.
         *
         *     Args:
         *         concept_id: Concept identifier to explain.
         *         style: Explanation style ('simple', 'detailed', or 'eli5').
         *         service: Injected assistant service.
         *
         *     Returns:
         *         ExplanationResponse with explanation, examples, and related concepts.
         *
         *     Raises:
         *         HTTPException 500: If explanation generation fails.
         */
        get: operations["explain_concept_api_assistant_explain__concept_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/graph": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Graph
         * @description Get all nodes and relationships from Neo4j.
         *
         *     Returns a graph structure with nodes and relationships.
         */
        get: operations["graph_graph_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Root
         * @description Root endpoint with API information.
         */
        get: operations["root__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AttemptConfidenceUpdate
         * @description Update confidence after viewing feedback.
         *
         *     Captures the learner's revised self-assessment after seeing the evaluation.
         *     Comparing confidence_before and confidence_after reveals calibration accuracy
         *     well-calibrated learners show smaller deltas between pre and post confidence.
         */
        AttemptConfidenceUpdate: {
            /** Confidence After */
            confidence_after: number;
        };
        /**
         * AttemptEvaluationResponse
         * @description Evaluation result for an exercise attempt.
         *
         *     Contains LLM-generated feedback analyzing the response against expected key points.
         *     Identifies covered points, missing concepts, and any misconceptions detected.
         *     For code exercises, includes detailed test results from sandbox execution.
         */
        AttemptEvaluationResponse: {
            /** Attempt Id */
            attempt_id: number;
            /** Attempt Uuid */
            attempt_uuid: string;
            /**
             * Score
             * @description Normalized score
             */
            score: number;
            /** Is Correct */
            is_correct: boolean;
            /**
             * Feedback
             * @description LLM-generated feedback
             */
            feedback: string;
            /**
             * Covered Points
             * @description Key points addressed
             */
            covered_points?: string[];
            /**
             * Missing Points
             * @description Key points missed
             */
            missing_points?: string[];
            /**
             * Misconceptions
             * @description Identified misconceptions
             */
            misconceptions?: string[];
            /** Tests Passed */
            tests_passed?: number | null;
            /** Tests Total */
            tests_total?: number | null;
            /** Test Results */
            test_results?: components["schemas"]["CodeExecutionResult"][] | null;
            /** Execution Error */
            execution_error?: string | null;
            exercise_with_solution?: components["schemas"]["ExerciseWithSolution"] | null;
        };
        /**
         * AttemptSubmitRequest
         * @description Request to submit an exercise attempt.
         *
         *     Supports both text responses (for conceptual exercises) and code responses
         *     (for programming exercises). The confidence_before field captures the learner's
         *     self-assessment prior to receiving feedback, enabling calibration tracking.
         */
        AttemptSubmitRequest: {
            /**
             * Exercise Id
             * @description Exercise ID
             */
            exercise_id: number;
            /**
             * Response
             * @description Text response
             */
            response?: string | null;
            /**
             * Response Code
             * @description Code response
             */
            response_code?: string | null;
            /**
             * Confidence Before
             * @description Self-reported confidence before (1-5)
             */
            confidence_before?: number | null;
            /** Time Spent Seconds */
            time_spent_seconds?: number | null;
        };
        /** Body_capture_book_api_capture_book_post */
        Body_capture_book_api_capture_book_post: {
            /**
             * Files
             * @description Multiple book page images
             */
            files: string[];
            /**
             * Title
             * @description Book title
             */
            title?: string | null;
            /**
             * Authors
             * @description Comma-separated author names
             */
            authors?: string | null;
            /**
             * Isbn
             * @description ISBN if known
             */
            isbn?: string | null;
            /**
             * Notes
             * @description Optional notes about this book
             */
            notes?: string | null;
            /**
             * Max Concurrency
             * @description Max parallel OCR calls (5-20 recommended)
             * @default 5
             */
            max_concurrency: number;
        };
        /** Body_capture_pdf_api_capture_pdf_post */
        Body_capture_pdf_api_capture_pdf_post: {
            /**
             * File
             * Format: binary
             * @description PDF file
             */
            file: string;
            /**
             * Content Type Hint
             * @description Hint: paper, article, book, or general
             */
            content_type_hint?: string | null;
            /**
             * Detect Handwriting
             * @description Detect handwritten annotations
             * @default true
             */
            detect_handwriting: boolean;
        };
        /** Body_capture_photo_api_capture_photo_post */
        Body_capture_photo_api_capture_photo_post: {
            /**
             * File
             * Format: binary
             * @description Photo file
             */
            file: string;
            /**
             * Capture Type
             * @description Type: book_page, whiteboard, document, or general
             * @default general
             */
            capture_type: string;
            /**
             * Notes
             * @description Optional notes
             */
            notes?: string | null;
            /**
             * Book Title
             * @description Book title if known
             */
            book_title?: string | null;
        };
        /** Body_capture_text_api_capture_text_post */
        Body_capture_text_api_capture_text_post: {
            /**
             * Content
             * @description Text content to capture
             */
            content: string;
            /**
             * Title
             * @description Optional title
             */
            title?: string | null;
            /**
             * Tags
             * @description Comma-separated tags
             */
            tags?: string | null;
        };
        /** Body_capture_url_api_capture_url_post */
        Body_capture_url_api_capture_url_post: {
            /**
             * Url
             * @description URL to capture
             */
            url: string;
            /**
             * Notes
             * @description Optional notes about this URL
             */
            notes?: string | null;
            /**
             * Tags
             * @description Comma-separated tags
             */
            tags?: string | null;
        };
        /** Body_capture_voice_api_capture_voice_post */
        Body_capture_voice_api_capture_voice_post: {
            /**
             * File
             * Format: binary
             * @description Audio file
             */
            file: string;
            /**
             * Expand
             * @description Expand transcript into structured note
             * @default true
             */
            expand: boolean;
        };
        /**
         * CardCreate
         * @description Request to create a new spaced repetition card.
         *
         *     Extends CardBase with optional source linking to content and Neo4j concepts.
         *     For code cards, includes language, starter template, solution, and test cases
         *     that enable automated evaluation in the code sandbox.
         */
        CardCreate: {
            /**
             * Card Type
             * @description Card type: concept, fact, application, cloze, code
             */
            card_type: string;
            /**
             * Front
             * @description Front side (question/prompt)
             */
            front: string;
            /**
             * Back
             * @description Back side (answer)
             */
            back: string;
            /**
             * Hints
             * @description Progressive hints
             */
            hints?: string[];
            /**
             * Tags
             * @description Topic tags
             */
            tags?: string[];
            /**
             * Content Id
             * @description Source content ID
             */
            content_id?: number | null;
            /**
             * Concept Id
             * @description Related concept ID in Neo4j
             */
            concept_id?: string | null;
            /**
             * Language
             * @description Programming language
             */
            language?: string | null;
            /**
             * Starter Code
             * @description Initial code template
             */
            starter_code?: string | null;
            /**
             * Solution Code
             * @description Reference solution
             */
            solution_code?: string | null;
            /**
             * Test Cases
             * @description Test cases for code cards
             */
            test_cases?: {
                [key: string]: unknown;
            }[] | null;
        };
        /**
         * CardEvaluateRequest
         * @description Request to evaluate a typed answer for a card.
         */
        CardEvaluateRequest: {
            /**
             * Card Id
             * @description Card ID
             */
            card_id: number;
            /**
             * User Answer
             * @description User's typed answer
             */
            user_answer: string;
        };
        /**
         * CardEvaluateResponse
         * @description Response from card answer evaluation.
         */
        CardEvaluateResponse: {
            /** Card Id */
            card_id: number;
            /**
             * Rating
             * @description FSRS rating (1-4)
             */
            rating: number;
            /**
             * Is Correct
             * @description Whether the answer is considered correct
             */
            is_correct: boolean;
            /**
             * Feedback
             * @description Explanation for the learner
             */
            feedback: string;
            /** Key Points Covered */
            key_points_covered?: string[];
            /** Key Points Missed */
            key_points_missed?: string[];
            /**
             * Expected Answer
             * @description The correct answer for comparison
             */
            expected_answer: string;
        };
        /**
         * CardGenerationRequest
         * @description Request to generate cards for a topic.
         */
        CardGenerationRequest: {
            /**
             * Topic
             * @description Topic path (e.g., 'ml/transformers')
             */
            topic: string;
            /**
             * Count
             * @description Number of cards to generate
             * @default 10
             */
            count: number;
            /**
             * Difficulty
             * @description Difficulty: easy, medium, hard, mixed
             * @default mixed
             */
            difficulty: string;
        };
        /**
         * CardGenerationResponse
         * @description Response from card generation.
         */
        CardGenerationResponse: {
            /** Generated Count */
            generated_count: number;
            /** Total Cards */
            total_cards: number;
            /** Topic */
            topic: string;
        };
        /**
         * CardResponse
         * @description Card response with FSRS state.
         *
         *     Includes the full FSRS scheduling state: stability (memory strength in days),
         *     difficulty (0-1 scale), and current learning state. The due_date indicates when
         *     the card should next be reviewed based on the FSRS-4.5 optimal retention algorithm.
         */
        CardResponse: {
            /**
             * Card Type
             * @description Card type: concept, fact, application, cloze, code
             */
            card_type: string;
            /**
             * Front
             * @description Front side (question/prompt)
             */
            front: string;
            /**
             * Back
             * @description Back side (answer)
             */
            back: string;
            /**
             * Hints
             * @description Progressive hints
             */
            hints?: string[];
            /**
             * Tags
             * @description Topic tags
             */
            tags?: string[];
            /** Id */
            id: number;
            /** Content Id */
            content_id?: number | null;
            /** Concept Id */
            concept_id?: string | null;
            /** @default new */
            state: components["schemas"]["CardState"];
            /**
             * Stability
             * @description Memory stability in days
             * @default 0
             */
            stability: number;
            /**
             * Difficulty
             * @description FSRS card difficulty (can exceed 1.0 after reviews)
             * @default 0.3
             */
            difficulty: number;
            /**
             * Due Date
             * Format: date-time
             */
            due_date: string;
            /** Last Reviewed */
            last_reviewed?: string | null;
            /**
             * Repetitions
             * @default 0
             */
            repetitions: number;
            /**
             * Lapses
             * @default 0
             */
            lapses: number;
            /**
             * Total Reviews
             * @default 0
             */
            total_reviews: number;
            /**
             * Correct Reviews
             * @default 0
             */
            correct_reviews: number;
            /** Language */
            language?: string | null;
        };
        /**
         * CardReviewRequest
         * @description Request to submit a card review rating.
         *
         *     The rating follows FSRS conventions: Again (1) for forgotten, Hard (2) for difficult
         *     recall, Good (3) for successful recall with effort, Easy (4) for effortless recall.
         *     Time spent is tracked for analytics and can inform future difficulty adjustments.
         */
        CardReviewRequest: {
            /**
             * Card Id
             * @description Card ID to review
             */
            card_id: number;
            /** @description Self-assessment rating (1-4) */
            rating: components["schemas"]["Rating"];
            /**
             * Response
             * @description Optional response text
             */
            response?: string | null;
            /**
             * Time Spent Seconds
             * @description Time spent on review
             */
            time_spent_seconds?: number | null;
        };
        /**
         * CardReviewResponse
         * @description Response after submitting a card review.
         *
         *     Contains the updated FSRS state after processing the review. The scheduled_days
         *     field shows when the card will next be due, which can range from minutes (for
         *     Again ratings) to months (for well-learned Easy cards with high stability).
         */
        CardReviewResponse: {
            /** Card Id */
            card_id: number;
            new_state: components["schemas"]["CardState"];
            /** New Stability */
            new_stability: number;
            /** New Difficulty */
            new_difficulty: number;
            /**
             * Next Due Date
             * Format: date-time
             */
            next_due_date: string;
            /**
             * Scheduled Days
             * @description Days until next review
             */
            scheduled_days: number;
            /**
             * Was Correct
             * @description Whether rating indicates success
             */
            was_correct: boolean;
        };
        /**
         * CardState
         * @description FSRS card states in the learning state machine.
         *
         *     State transitions:
         *     - NEW  LEARNING (first review)
         *     - LEARNING  REVIEW (graduated) or LEARNING (still learning)
         *     - REVIEW  REVIEW (success) or RELEARNING (lapse)
         *     - RELEARNING  REVIEW (recovered) or RELEARNING (still struggling)
         * @enum {string}
         */
        CardState: "new" | "learning" | "review" | "relearning";
        /**
         * CardStats
         * @description Statistics about cards in the system.
         *
         *     Provides aggregate metrics for the card collection including state distribution,
         *     average stability/difficulty, and review workload. Useful for understanding
         *     overall system health and planning study capacity.
         */
        CardStats: {
            /** Total Cards */
            total_cards: number;
            /**
             * Cards By State
             * @description Count per CardState
             */
            cards_by_state?: {
                [key: string]: number;
            };
            /**
             * Avg Stability
             * @default 0
             */
            avg_stability: number;
            /**
             * Avg Difficulty
             * @default 0
             */
            avg_difficulty: number;
            /**
             * Due Today
             * @default 0
             */
            due_today: number;
            /**
             * Overdue
             * @default 0
             */
            overdue: number;
        };
        /**
         * ChatRequest
         * @description Request to send a message to the AI assistant.
         *
         *     Attributes:
         *         conversation_id: Existing conversation ID (null to start new conversation)
         *         message: User message content
         */
        ChatRequest: {
            /**
             * Conversation Id
             * @description Conversation ID (null to start new conversation)
             */
            conversation_id?: string | null;
            /** Message */
            message: string;
        };
        /**
         * ChatResponse
         * @description Response from the AI assistant.
         *
         *     Attributes:
         *         conversation_id: The conversation this message belongs to
         *         response: Assistant's response text
         *         sources: Optional list of referenced sources
         */
        ChatResponse: {
            /** Conversation Id */
            conversation_id: string;
            /** Response */
            response: string;
            /** Sources */
            sources?: components["schemas"]["SourceReference"][];
        };
        /**
         * CodeExecutionResult
         * @description Result of a single test case execution.
         *
         *     Captures the outcome of running learner code against a test case in the sandbox.
         *     Includes input/expected/actual values for debugging failed tests, and any
         *     execution errors (syntax errors, exceptions, timeouts) that occurred.
         *
         *     Note: Named CodeExecutionResult (not TestResult) to avoid pytest collection warnings.
         */
        CodeExecutionResult: {
            /** Test Index */
            test_index: number;
            /** Passed */
            passed: boolean;
            /** Input Value */
            input_value?: string | null;
            /** Expected */
            expected?: string | null;
            /** Actual */
            actual?: string | null;
            /** Error */
            error?: string | null;
        };
        /**
         * Concept
         * @description Extracted concept with rich context for knowledge building.
         *
         *     Concepts are the atomic units of knowledge in the graph. They enable
         *     rich querying, connection discovery, and knowledge gap identification.
         *
         *     Attributes:
         *         id: Unique identifier (UUID v4)
         *         name: Concept name (e.g., "attention mechanism", "transformer")
         *         definition: Clear, concise definition in 1-2 sentences
         *         context: How this concept is used in THIS specific content
         *         importance: Role in the content (core, supporting, tangential)
         *         why_it_matters: Explanation of why this concept is important
         *         properties: Key characteristics or attributes of the concept
         *         examples: Concrete examples illustrating the concept
         *         misconceptions: Common misunderstandings about the concept
         *         prerequisites: Concepts that should be understood first
         *         related_concepts: Other concepts this one connects to with relationship type
         *         embedding: Vector embedding for similarity search (computed post-extraction)
         */
        Concept: {
            /** Id */
            id?: string;
            /**
             * Name
             * @description Concept name
             */
            name: string;
            /**
             * Definition
             * @description Clear definition in 1-2 sentences
             */
            definition: string;
            /**
             * Context
             * @description How it's used in this specific content
             * @default
             */
            context: string;
            /**
             * Importance
             * @description CORE, SUPPORTING, or TANGENTIAL
             * @default SUPPORTING
             */
            importance: string;
            /**
             * Why It Matters
             * @description Why this concept is important to understand
             * @default
             */
            why_it_matters: string;
            /**
             * Properties
             * @description Key characteristics of this concept
             */
            properties?: string[];
            /**
             * Examples
             * @description Concrete examples illustrating the concept
             */
            examples?: components["schemas"]["ConceptExample"][];
            /**
             * Misconceptions
             * @description Common misunderstandings
             */
            misconceptions?: components["schemas"]["ConceptMisconception"][];
            /**
             * Prerequisites
             * @description Concepts that should be understood first
             */
            prerequisites?: string[];
            /**
             * Related Concepts
             * @description Related concepts with relationship type
             */
            related_concepts?: components["schemas"]["ConceptRelation"][];
            /**
             * Embedding
             * @description Vector embedding for similarity search (computed post-extraction)
             */
            embedding?: number[] | null;
            /**
             * Neo4J Node Id
             * @description ID of corresponding Neo4j node (set after storage)
             */
            neo4j_node_id?: string | null;
        };
        /**
         * ConceptExample
         * @description An example illustrating a concept.
         */
        ConceptExample: {
            /**
             * Title
             * @description Example title
             * @default
             */
            title: string;
            /**
             * Content
             * @description Example explanation
             */
            content: string;
        };
        /**
         * ConceptMisconception
         * @description A common misconception about a concept.
         */
        ConceptMisconception: {
            /**
             * Wrong
             * @description The incorrect belief
             */
            wrong: string;
            /**
             * Correct
             * @description The correct understanding
             */
            correct: string;
        };
        /**
         * ConceptRelation
         * @description A relationship to another concept.
         */
        ConceptRelation: {
            /**
             * Name
             * @description Related concept name
             */
            name: string;
            /**
             * Relationship
             * @description How they're related
             * @default relates to
             */
            relationship: string;
        };
        /**
         * Connection
         * @description Connection to existing knowledge.
         *
         *     Represents a semantic relationship between new content and existing
         *     content in the knowledge graph. Enables the "web" of connections.
         *
         *     Attributes:
         *         id: Unique identifier for this connection
         *         target_id: ID of the connected content/concept
         *         target_title: Title of the connected item (for display)
         *         relationship_type: Type of relationship (RELATES_TO, EXTENDS, etc.)
         *         strength: Connection strength from 0.0 to 1.0
         *         explanation: Brief explanation of why these are connected
         *         verified_by_user: Whether user has confirmed this connection
         */
        Connection: {
            /** Id */
            id?: string;
            /**
             * Target Id
             * @description ID of connected content/concept
             */
            target_id: string;
            /**
             * Target Title
             * @description Title for display
             */
            target_title: string;
            /**
             * Relationship Type
             * @description RELATES_TO, EXTENDS, CONTRADICTS, PREREQUISITE_FOR, APPLIES
             * @default RELATES_TO
             */
            relationship_type: string;
            /**
             * Strength
             * @description Connection strength (0-1)
             * @default 0.5
             */
            strength: number;
            /**
             * Explanation
             * @description Why these are connected
             * @default
             */
            explanation: string;
            /**
             * Verified By User
             * @description Whether user has confirmed this connection
             * @default false
             */
            verified_by_user: boolean;
        };
        /**
         * ConnectionDirection
         * @description Direction filter for connection queries.
         *
         *     Used by the /connections/{node_id} endpoint to filter
         *     relationships by direction relative to the queried node.
         *
         *     Values:
         *         INCOMING: Only relationships pointing to the node
         *         OUTGOING: Only relationships pointing from the node
         *         BOTH: All relationships (default)
         * @enum {string}
         */
        ConnectionDirection: "incoming" | "outgoing" | "both";
        /**
         * ConnectionsResponse
         * @description Response containing connections for a node.
         *
         *     Returns both incoming and outgoing relationships,
         *     enabling bidirectional graph exploration.
         *
         *     Attributes:
         *         node_id: The queried node's ID
         *         incoming: Connections pointing to this node
         *         outgoing: Connections pointing from this node
         *         total: Total connection count
         */
        ConnectionsResponse: {
            /** Node Id */
            node_id: string;
            /** Incoming */
            incoming: components["schemas"]["NodeConnection"][];
            /** Outgoing */
            outgoing: components["schemas"]["NodeConnection"][];
            /** Total */
            total: number;
        };
        /**
         * ContentAnalysis
         * @description Result of initial content analysis.
         *
         *     This is the first processing stage output that determines how subsequent
         *     stages behave. Identifying content type, domain, complexity, and key topics
         *     allows the pipeline to use appropriate prompts and model configurations.
         *
         *     Attributes:
         *         content_type: Type of content (paper, article, book, code, idea, voice_memo)
         *         domain: Primary domain (ml, systems, leadership, productivity, etc.)
         *         complexity: Difficulty level (foundational, intermediate, advanced)
         *         estimated_length: Content length category (short, medium, long)
         *         has_code: Whether content contains code snippets
         *         has_math: Whether content contains mathematical notation
         *         has_diagrams: Whether content contains diagrams or figures
         *         key_topics: Main topics covered (up to 10)
         *         language: ISO language code (default: en)
         */
        ContentAnalysis: {
            /**
             * Content Type
             * @description Type: paper, article, book, code, idea, voice_memo
             */
            content_type: string;
            /**
             * Domain
             * @description Primary domain: ml, systems, leadership, productivity, etc.
             */
            domain: string;
            /**
             * Complexity
             * @description Difficulty: foundational, intermediate, advanced
             */
            complexity: string;
            /**
             * Estimated Length
             * @description Length category: short, medium, long
             */
            estimated_length: string;
            /**
             * Has Code
             * @default false
             */
            has_code: boolean;
            /**
             * Has Math
             * @default false
             */
            has_math: boolean;
            /**
             * Has Diagrams
             * @default false
             */
            has_diagrams: boolean;
            /**
             * Key Topics
             * @description Main topics covered (up to 10)
             */
            key_topics?: string[];
            /**
             * Language
             * @description ISO language code
             * @default en
             */
            language: string;
        };
        /**
         * ConversationDetail
         * @description Full conversation with all messages.
         *
         *     Attributes:
         *         id: Conversation unique identifier
         *         title: Conversation title
         *         created_at: When the conversation started
         *         messages: All messages in chronological order
         */
        ConversationDetail: {
            /** Id */
            id: string;
            /** Title */
            title: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Messages */
            messages: components["schemas"]["MessageInfo"][];
        };
        /**
         * ConversationListResponse
         * @description Paginated list of conversations.
         *
         *     Attributes:
         *         conversations: List of conversation summaries
         *         total: Total number of conversations
         */
        ConversationListResponse: {
            /** Conversations */
            conversations: components["schemas"]["ConversationSummary"][];
            /** Total */
            total: number;
        };
        /**
         * ConversationSummary
         * @description Summary of a conversation for list views.
         *
         *     Attributes:
         *         id: Conversation unique identifier
         *         title: Conversation title (auto-generated or user-set)
         *         created_at: When the conversation started
         *         updated_at: When the conversation was last updated
         *         message_count: Number of messages in the conversation
         */
        ConversationSummary: {
            /** Id */
            id: string;
            /** Title */
            title: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             */
            updated_at: string;
            /** Message Count */
            message_count: number;
        };
        /**
         * ConversationUpdateRequest
         * @description Request to update conversation metadata.
         *
         *     Attributes:
         *         title: New title for the conversation
         */
        ConversationUpdateRequest: {
            /** Title */
            title: string;
        };
        /**
         * ConversationUpdateResponse
         * @description Response after updating a conversation.
         *
         *     Attributes:
         *         id: Conversation unique identifier
         *         title: Updated title
         *         updated_at: When the update was made
         */
        ConversationUpdateResponse: {
            /** Id */
            id: string;
            /** Title */
            title: string;
            /**
             * Updated At
             * Format: date-time
             */
            updated_at: string;
        };
        /** DailyNoteRequest */
        DailyNoteRequest: {
            /** Date */
            date?: string | null;
        };
        /**
         * DailyStatsResponse
         * @description Daily statistics for the dashboard.
         *
         *     Provides a quick overview of today's learning status including due cards,
         *     streak information, and recent activity. Used by the frontend dashboard
         *     to show the user's current learning status at a glance.
         */
        DailyStatsResponse: {
            /**
             * Streak Days
             * @description Current consecutive practice days
             * @default 0
             */
            streak_days: number;
            /**
             * Streak At Risk
             * @description True if no practice today yet
             * @default false
             */
            streak_at_risk: boolean;
            /**
             * Due Cards Count
             * @description Cards due for review today
             * @default 0
             */
            due_cards_count: number;
            /**
             * Total Cards
             * @description Total cards in the system
             * @default 0
             */
            total_cards: number;
            /**
             * Cards Reviewed Today
             * @description Cards reviewed so far today
             * @default 0
             */
            cards_reviewed_today: number;
            /**
             * Overall Mastery
             * @description Overall mastery score
             * @default 0
             */
            overall_mastery: number;
            /**
             * Practice Time Today Minutes
             * @description Practice time today in minutes
             * @default 0
             */
            practice_time_today_minutes: number;
            /**
             * Last Practice Date
             * @description Date of last practice
             */
            last_practice_date?: string | null;
        };
        /**
         * DeleteResponse
         * @description Generic deletion response.
         *
         *     Attributes:
         *         success: Whether the deletion was successful
         *         deleted_id: ID of the deleted resource (optional)
         *         cleared_count: Number of items cleared (optional)
         */
        DeleteResponse: {
            /** Success */
            success: boolean;
            /** Deleted Id */
            deleted_id?: string | null;
            /** Cleared Count */
            cleared_count?: number | null;
        };
        /**
         * DueCardsResponse
         * @description Response with due cards and forecast.
         *
         *     Returns cards ordered by due date (oldest first) along with the total count
         *     of due cards and a forecast of upcoming reviews. The forecast helps users
         *     understand their review backlog and plan study sessions accordingly.
         */
        DueCardsResponse: {
            /** Cards */
            cards: components["schemas"]["CardResponse"][];
            /** Total Due */
            total_due: number;
            review_forecast: components["schemas"]["ReviewForecast"];
        };
        /**
         * ExerciseDifficulty
         * @description Difficulty levels aligned with mastery progression.
         *
         *     Difficulty selection is adaptive based on learner mastery:
         *     - mastery < 0.3: FOUNDATIONAL (worked examples, completions)
         *     - mastery 0.3-0.7: INTERMEDIATE (free recall, implementations)
         *     - mastery > 0.7: ADVANCED (applications, refactoring)
         * @enum {string}
         */
        ExerciseDifficulty: "foundational" | "intermediate" | "advanced";
        /**
         * ExerciseGenerateRequest
         * @description Request to generate an exercise.
         *
         *     The LLM exercise generator uses the topic and optional source content to create
         *     a contextually relevant exercise. If type/difficulty are not specified, they are
         *     automatically selected based on the learner's current mastery level for the topic.
         */
        ExerciseGenerateRequest: {
            /**
             * Topic
             * @description Topic to generate exercise for
             */
            topic: string;
            /** @description Specific type, or auto-select based on mastery */
            exercise_type?: components["schemas"]["ExerciseType"] | null;
            /** @description Specific difficulty, or auto-select based on mastery */
            difficulty?: components["schemas"]["ExerciseDifficulty"] | null;
            /**
             * Language
             * @description Programming language for code exercises
             */
            language?: string | null;
            /**
             * Source Content Ids
             * @description Optional content IDs to base exercise on
             */
            source_content_ids?: string[];
        };
        /**
         * ExerciseResponse
         * @description Exercise response (hides solution until attempted).
         *
         *     Returns the exercise prompt and any scaffolding (hints, starter code, buggy code)
         *     but withholds the solution until after the learner submits an attempt. This
         *     prevents premature exposure to answers and encourages genuine retrieval practice.
         */
        ExerciseResponse: {
            exercise_type: components["schemas"]["ExerciseType"];
            /**
             * Topic
             * @description Topic path (e.g., ml/transformers)
             */
            topic: string;
            /** @default intermediate */
            difficulty: components["schemas"]["ExerciseDifficulty"];
            /**
             * Prompt
             * @description Main exercise prompt
             */
            prompt: string;
            /**
             * Hints
             * @description Progressive hints
             */
            hints?: string[];
            /**
             * Expected Key Points
             * @description Key points for a good answer
             */
            expected_key_points?: string[];
            /** Id */
            id: number;
            /** Exercise Uuid */
            exercise_uuid: string;
            /** Worked Example */
            worked_example?: string | null;
            /** Follow Up Problem */
            follow_up_problem?: string | null;
            /** Language */
            language?: string | null;
            /** Starter Code */
            starter_code?: string | null;
            /** Buggy Code */
            buggy_code?: string | null;
            /**
             * Estimated Time Minutes
             * @default 10
             */
            estimated_time_minutes: number;
            /** Tags */
            tags?: string[];
        };
        /**
         * ExerciseType
         * @description Types of exercises for active learning.
         *
         *     Text-based exercises:
         *     - FREE_RECALL: Explain concept from memory
         *     - SELF_EXPLAIN: Explain why/how something works
         *     - WORKED_EXAMPLE: Step-by-step solution followed by similar problem
         *     - APPLICATION: Apply concept to novel situation
         *     - COMPARE_CONTRAST: Compare two concepts or approaches
         *     - TEACH_BACK: Explain as if teaching someone (Feynman technique)
         *
         *     Code-based exercises:
         *     - CODE_IMPLEMENT: Write code from scratch
         *     - CODE_COMPLETE: Fill in blanks in code
         *     - CODE_DEBUG: Find and fix bugs
         *     - CODE_REFACTOR: Improve existing code
         *     - CODE_EXPLAIN: Explain what code does
         * @enum {string}
         */
        ExerciseType: "free_recall" | "self_explain" | "worked_example" | "application" | "compare_contrast" | "teach_back" | "code_implement" | "code_complete" | "code_debug" | "code_refactor" | "code_explain";
        /**
         * ExerciseWithSolution
         * @description Exercise with solution revealed (after attempt).
         *
         *     Extends ExerciseResponse to include the reference solution and test cases.
         *     Only returned after the learner submits an attempt, enabling comparison
         *     between their response and the expected answer for self-assessment.
         */
        ExerciseWithSolution: {
            exercise_type: components["schemas"]["ExerciseType"];
            /**
             * Topic
             * @description Topic path (e.g., ml/transformers)
             */
            topic: string;
            /** @default intermediate */
            difficulty: components["schemas"]["ExerciseDifficulty"];
            /**
             * Prompt
             * @description Main exercise prompt
             */
            prompt: string;
            /**
             * Hints
             * @description Progressive hints
             */
            hints?: string[];
            /**
             * Expected Key Points
             * @description Key points for a good answer
             */
            expected_key_points?: string[];
            /** Id */
            id: number;
            /** Exercise Uuid */
            exercise_uuid: string;
            /** Worked Example */
            worked_example?: string | null;
            /** Follow Up Problem */
            follow_up_problem?: string | null;
            /** Language */
            language?: string | null;
            /** Starter Code */
            starter_code?: string | null;
            /** Buggy Code */
            buggy_code?: string | null;
            /**
             * Estimated Time Minutes
             * @default 10
             */
            estimated_time_minutes: number;
            /** Tags */
            tags?: string[];
            /** Solution Code */
            solution_code?: string | null;
            /** Test Cases */
            test_cases?: {
                [key: string]: unknown;
            }[] | null;
        };
        /**
         * ExplanationResponse
         * @description AI-generated explanation of a concept.
         *
         *     Attributes:
         *         concept: Concept name
         *         explanation: Detailed explanation text
         *         examples: Optional list of examples
         *         related_concepts: Optional list of related concepts
         */
        ExplanationResponse: {
            /** Concept */
            concept: string;
            /** Explanation */
            explanation: string;
            /** Examples */
            examples?: string[];
            /** Related Concepts */
            related_concepts?: components["schemas"]["RelatedConcept"][];
        };
        /**
         * ExplanationStyle
         * @description Style for AI-generated concept explanations.
         *
         *     Controls the verbosity and complexity of explanations returned
         *     by the assistant's explain endpoint.
         *
         *     Usage:
         *         from app.enums import ExplanationStyle
         *
         *         style = ExplanationStyle.ELI5
         * @enum {string}
         */
        ExplanationStyle: "simple" | "detailed" | "eli5";
        /**
         * ExtractionResult
         * @description Result of concept extraction stage.
         *
         *     Contains all structured information extracted from content including
         *     concepts, key findings, methodologies, tools, and people mentioned.
         *
         *     Attributes:
         *         concepts: List of extracted concepts with definitions
         *         key_findings: Main insights, conclusions, or claims
         *         methodologies: Approaches, techniques, algorithms described
         *         tools_mentioned: Software, frameworks, libraries mentioned
         *         people_mentioned: Authors, researchers, thought leaders referenced
         */
        ExtractionResult: {
            /** Concepts */
            concepts?: components["schemas"]["Concept"][];
            /** Key Findings */
            key_findings?: string[];
            /** Methodologies */
            methodologies?: string[];
            /** Tools Mentioned */
            tools_mentioned?: string[];
            /** People Mentioned */
            people_mentioned?: string[];
        };
        /**
         * FollowupTask
         * @description Generated follow-up task.
         *
         *     Follow-up tasks transform passive reading into active learning. They help
         *     users engage more deeply with content by providing specific, actionable
         *     next steps.
         *
         *     Attributes:
         *         id: Unique identifier
         *         task: Specific, actionable task description
         *         task_type: Category (research, practice, connect, apply, review)
         *         priority: Importance level (high, medium, low)
         *         estimated_time: Time estimate (15min, 30min, 1hr, 2hr+)
         *         completed: Whether the task has been completed
         *         completed_at: When the task was completed
         *         created_at: When the task was created
         */
        FollowupTask: {
            /** Id */
            id?: string;
            /**
             * Task
             * @description Specific, actionable task description
             */
            task: string;
            /**
             * Task Type
             * @description research, practice, connect, apply, review
             * @default research
             */
            task_type: string;
            /**
             * Priority
             * @description high, medium, low
             * @default medium
             */
            priority: string;
            /**
             * Estimated Time
             * @description 15min, 30min, 1hr, 2hr+
             * @default 30min
             */
            estimated_time: string;
            /**
             * Completed
             * @description Whether task is done
             * @default false
             */
            completed: boolean;
            /**
             * Completed At
             * @description When the task was completed
             */
            completed_at?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description When the task was created
             */
            created_at?: string;
        };
        /**
         * GitHubSyncRequest
         * @description Request body for GitHub sync.
         */
        GitHubSyncRequest: {
            /**
             * Limit
             * @default 50
             */
            limit: number;
        };
        /**
         * GraphEdge
         * @description Lightweight edge for graph visualization.
         *
         *     Designed for bulk transfer in graph visualization responses where
         *     hundreds of edges may be returned. Contains only IDs and visual
         *     properties - no display metadata to minimize payload size.
         *
         *     For detailed connection information with titles and context,
         *     see NodeConnection which is used by the /connections endpoint.
         *
         *     Attributes:
         *         source: Source node ID
         *         target: Target node ID
         *         type: Relationship type (REFERENCES, RELATES_TO, etc.)
         *         strength: Edge weight from 0.0 to 1.0 for visual thickness
         *         label: Optional display label for the edge
         *
         *     See Also:
         *         NodeConnection: Rich connection model with display metadata
         *         GraphResponse: Uses GraphEdge for visualization data
         */
        GraphEdge: {
            /** Source */
            source: string;
            /** Target */
            target: string;
            /** Type */
            type: string;
            /**
             * Strength
             * @default 1
             */
            strength: number;
            /** Label */
            label?: string | null;
        };
        /**
         * GraphNode
         * @description Node in the knowledge graph visualization.
         *
         *     Represents a single entity (Content, Concept, or Note) in the graph
         *     with properties needed for D3.js force-directed rendering.
         *
         *     Attributes:
         *         id: Unique node identifier (UUID or Neo4j ID)
         *         label: Display title for the node
         *         type: Node type - "Content", "Concept", or "Note"
         *         content_type: For Content nodes, the specific type (paper, article, etc.)
         *         size: Visual weight based on connection count (for node sizing)
         *         color: Optional hex color code for custom styling
         *         metadata: Additional properties (tags, etc.)
         */
        GraphNode: {
            /** Id */
            id: string;
            /** Label */
            label: string;
            /** Type */
            type: string;
            /** Content Type */
            content_type?: string | null;
            /**
             * Size
             * @description Node size weight based on connections
             * @default 1
             */
            size: number;
            /**
             * Color
             * @description Optional hex color code
             */
            color?: string | null;
            /**
             * Metadata
             * @description Additional properties
             */
            metadata?: {
                [key: string]: unknown;
            };
        };
        /**
         * GraphResponse
         * @description Response containing graph data for visualization.
         *
         *     Returns a subgraph suitable for rendering with D3.js or similar
         *     visualization libraries. Includes metadata about the full graph size.
         *
         *     Attributes:
         *         nodes: List of nodes in the subgraph
         *         edges: List of edges connecting the nodes
         *         center_id: ID of the center node (if centered query)
         *         total_nodes: Total nodes in the full graph (before limiting)
         *         total_edges: Total edges in the returned subgraph
         */
        GraphResponse: {
            /** Nodes */
            nodes: components["schemas"]["GraphNode"][];
            /** Edges */
            edges: components["schemas"]["GraphEdge"][];
            /** Center Id */
            center_id?: string | null;
            /** Total Nodes */
            total_nodes: number;
            /** Total Edges */
            total_edges: number;
        };
        /**
         * GraphStats
         * @description Summary statistics for the knowledge graph.
         *
         *     Provides aggregate metrics about the graph contents
         *     for dashboard displays and health monitoring.
         *
         *     Attributes:
         *         total_content: Count of Content nodes
         *         total_concepts: Count of Concept nodes
         *         total_notes: Count of Note nodes
         *         total_relationships: Count of all relationships
         *         content_by_type: Breakdown of content by type (paper, article, etc.)
         */
        GraphStats: {
            /** Total Content */
            total_content: number;
            /** Total Concepts */
            total_concepts: number;
            /** Total Notes */
            total_notes: number;
            /** Total Relationships */
            total_relationships: number;
            /** Content By Type */
            content_by_type?: {
                [key: string]: number;
            };
        };
        /**
         * GroupBy
         * @description Grouping strategy for time-series analytics data.
         *
         *     Determines how time investment and other metrics are bucketed
         *     for visualization and trend analysis.
         * @enum {string}
         */
        GroupBy: "day" | "week" | "month";
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** InboxItemRequest */
        InboxItemRequest: {
            /** Item */
            item: string;
            /** Date */
            date?: string | null;
        };
        /**
         * KnowledgeSearchResponse
         * @description Response containing search results.
         *
         *     Attributes:
         *         results: List of matching results
         */
        KnowledgeSearchResponse: {
            /** Results */
            results: components["schemas"]["KnowledgeSearchResult"][];
        };
        /**
         * KnowledgeSearchResult
         * @description A single search result from the knowledge base.
         *
         *     Attributes:
         *         id: Content or concept ID
         *         title: Display title
         *         snippet: Relevant text snippet
         *         score: Relevance score (0-1)
         *         type: Type of content (e.g., "paper", "note", "concept")
         */
        KnowledgeSearchResult: {
            /** Id */
            id: string;
            /** Title */
            title: string;
            /** Snippet */
            snippet: string;
            /** Score */
            score: number;
            /** Type */
            type: string;
        };
        /**
         * LearningCurveDataPoint
         * @description Single data point for learning curve.
         *
         *     Represents a daily snapshot of mastery metrics for time-series visualization.
         *     The retention_estimate shows predicted recall probability, while cards_reviewed
         *     indicates study activity level for that day.
         */
        LearningCurveDataPoint: {
            /**
             * Date
             * Format: date-time
             */
            date: string;
            /** Mastery Score */
            mastery_score: number;
            /** Retention Estimate */
            retention_estimate?: number | null;
            /**
             * Cards Reviewed
             * @default 0
             */
            cards_reviewed: number;
        };
        /**
         * LearningCurveResponse
         * @description Learning curve data for visualization.
         *
         *     Contains historical mastery data points for charting progress over time.
         *     The trend indicator and 30-day projection help learners understand their
         *     trajectory and estimate when they'll reach mastery milestones.
         */
        LearningCurveResponse: {
            /**
             * Topic
             * @description Topic or None for overall
             */
            topic?: string | null;
            /** Data Points */
            data_points: components["schemas"]["LearningCurveDataPoint"][];
            trend: components["schemas"]["MasteryTrend"];
            /** Projected Mastery 30D */
            projected_mastery_30d?: number | null;
        };
        /**
         * LogTimeRequest
         * @description Request to log learning time.
         *
         *     Captures time spent on learning activities for analytics. Supports various
         *     activity types (review, practice, reading, exercise) and can be linked to
         *     specific content, topics, or practice sessions for detailed tracking.
         */
        LogTimeRequest: {
            /**
             * Activity Type
             * @description Type: review, practice, reading, exercise
             */
            activity_type: string;
            /**
             * Started At
             * Format: date-time
             */
            started_at: string;
            /**
             * Ended At
             * Format: date-time
             */
            ended_at: string;
            /** Topic */
            topic?: string | null;
            /** Content Id */
            content_id?: number | null;
            /** Session Id */
            session_id?: number | null;
            /**
             * Items Completed
             * @default 0
             */
            items_completed: number;
        };
        /**
         * LogTimeResponse
         * @description Response after logging time.
         *
         *     Confirms the time log was recorded and returns the calculated duration.
         *     The human-readable message provides quick feedback to the user about
         *     how much time was logged.
         */
        LogTimeResponse: {
            /** Id */
            id: number;
            /** Duration Seconds */
            duration_seconds: number;
            /** Message */
            message: string;
        };
        /**
         * MasteryOverview
         * @description Overall mastery statistics.
         *
         *     Provides a dashboard view of learning progress across all topics. Card counts
         *     show distribution across learning states (new, learning, mastered). The streak
         *     counter motivates consistent daily practice through gamification.
         */
        MasteryOverview: {
            /** Overall Mastery */
            overall_mastery: number;
            /** Topics */
            topics: components["schemas"]["MasteryState"][];
            /** Total Cards */
            total_cards: number;
            /**
             * Cards Mastered
             * @description Cards with stability >= 21 days
             */
            cards_mastered: number;
            /** Cards Learning */
            cards_learning: number;
            /** Cards New */
            cards_new: number;
            /**
             * Streak Days
             * @description Consecutive practice days
             * @default 0
             */
            streak_days: number;
            /**
             * Total Practice Time Hours
             * @default 0
             */
            total_practice_time_hours: number;
        };
        /**
         * MasteryQuestion
         * @description Generated mastery question.
         *
         *     Mastery questions enable active recall and self-testing. If a user can
         *     answer these questions from memory, they truly understand the material.
         *
         *     Attributes:
         *         id: Unique identifier
         *         question: Clear, specific question text
         *         question_type: Category (conceptual, application, analysis, synthesis)
         *         difficulty: Level (foundational, intermediate, advanced)
         *         hints: Progressive hints for struggling users
         *         key_points: Key points a good answer should include
         *         next_review_at: When to show again (spaced repetition)
         *         review_count: Number of times reviewed
         *         ease_factor: SM-2 ease factor for spaced repetition
         *         created_at: When the question was created
         */
        MasteryQuestion: {
            /** Id */
            id?: string;
            /**
             * Question
             * @description Clear, specific question
             */
            question: string;
            /**
             * Question Type
             * @description conceptual, application, analysis, synthesis
             * @default conceptual
             */
            question_type: string;
            /**
             * Difficulty
             * @description foundational, intermediate, advanced
             * @default intermediate
             */
            difficulty: string;
            /**
             * Hints
             * @description Progressive hints
             */
            hints?: string[];
            /**
             * Key Points
             * @description Key points for a good answer
             */
            key_points?: string[];
            /**
             * Next Review At
             * @description When to show again (spaced repetition)
             */
            next_review_at?: string | null;
            /**
             * Review Count
             * @description Number of times reviewed
             * @default 0
             */
            review_count: number;
            /**
             * Ease Factor
             * @description SM-2 ease factor for spaced repetition
             * @default 2.5
             */
            ease_factor: number;
            /**
             * Created At
             * Format: date-time
             * @description When the question was created
             */
            created_at?: string;
        };
        /**
         * MasteryState
         * @description Mastery state for a topic.
         *
         *     Combines card-based metrics (stability, success rate) with practice history
         *     to estimate topic mastery. The retention_estimate predicts current recall
         *     probability based on time since last review and card stability.
         */
        MasteryState: {
            /** Topic Path */
            topic_path: string;
            /** Mastery Score */
            mastery_score: number;
            /** Confidence Avg */
            confidence_avg?: number | null;
            /**
             * Practice Count
             * @default 0
             */
            practice_count: number;
            /** Success Rate */
            success_rate?: number | null;
            /** @default stable */
            trend: components["schemas"]["MasteryTrend"];
            /** Last Practiced */
            last_practiced?: string | null;
            /** Retention Estimate */
            retention_estimate?: number | null;
            /** Days Since Review */
            days_since_review?: number | null;
        };
        /**
         * MasteryTrend
         * @description Trend direction for mastery tracking.
         *
         *     Calculated by comparing current mastery to previous snapshot:
         *     - delta > 0.05: IMPROVING
         *     - delta < -0.05: DECLINING
         *     - else: STABLE
         * @enum {string}
         */
        MasteryTrend: "improving" | "stable" | "declining";
        /**
         * MessageInfo
         * @description A single message in a conversation.
         *
         *     Attributes:
         *         id: Message unique identifier
         *         role: Message role (user or assistant)
         *         content: Message content
         *         timestamp: When the message was sent
         */
        MessageInfo: {
            /** Id */
            id: string;
            /**
             * Role
             * @enum {string}
             */
            role: "user" | "assistant";
            /** Content */
            content: string;
            /**
             * Timestamp
             * Format: date-time
             */
            timestamp: string;
        };
        /**
         * NodeConnection
         * @description Rich connection model with display metadata.
         *
         *     Used by the /connections/{node_id} endpoint to return detailed
         *     information about a node's relationships. Includes display-ready
         *     metadata (titles, types, context) so the UI can render connection
         *     lists without additional lookups.
         *
         *     For bulk graph visualization where payload size matters,
         *     see GraphEdge which contains only IDs and visual properties.
         *
         *     Note: Named NodeConnection to distinguish from app.models.processing.Connection
         *     which represents LLM-discovered connections during content processing.
         *
         *     Attributes:
         *         source_id: Source node ID
         *         target_id: Target node ID
         *         target_title: Title of the connected node (for display)
         *         target_type: Type of the connected node (Content, Concept, Note)
         *         relationship: Relationship type (REFERENCES, RELATES_TO, etc.)
         *         strength: Connection strength from 0.0 to 1.0
         *         context: Optional explanation of why they're connected
         *
         *     See Also:
         *         GraphEdge: Lightweight edge for visualization (IDs only)
         *         ConnectionsResponse: Uses NodeConnection for detailed queries
         */
        NodeConnection: {
            /** Source Id */
            source_id: string;
            /** Target Id */
            target_id: string;
            /** Target Title */
            target_title: string;
            /** Target Type */
            target_type: string;
            /** Relationship */
            relationship: string;
            /**
             * Strength
             * @default 1
             */
            strength: number;
            /** Context */
            context?: string | null;
        };
        /**
         * NodeDetails
         * @description Detailed information about a single node.
         *
         *     Returns comprehensive metadata for a node detail view,
         *     including content summary, tags, and connection count.
         *
         *     Attributes:
         *         id: Node identifier
         *         label: Display title
         *         type: Node type (Content, Concept, Note)
         *         content_type: Specific content type if applicable
         *         summary: Brief summary text
         *         tags: List of associated tags
         *         source_url: Original source URL if applicable
         *         created_at: Creation timestamp (ISO 8601)
         *         connections: Count of connected nodes
         *         file_path: Obsidian vault file path if applicable
         *         name: Alternative name field (for Concepts)
         */
        NodeDetails: {
            /** Id */
            id: string;
            /** Label */
            label: string;
            /** Type */
            type: string;
            /** Content Type */
            content_type?: string | null;
            /** Summary */
            summary?: string | null;
            /** Tags */
            tags?: string[];
            /** Source Url */
            source_url?: string | null;
            /** Created At */
            created_at?: string | null;
            /**
             * Connections
             * @default 0
             */
            connections: number;
            /** File Path */
            file_path?: string | null;
            /** Name */
            name?: string | null;
        };
        /**
         * NoteContent
         * @description Full note content with metadata.
         */
        NoteContent: {
            /** Path */
            path: string;
            /** Name */
            name: string;
            /** Content */
            content: string;
            /**
             * Frontmatter
             * @default {}
             */
            frontmatter: {
                [key: string]: unknown;
            };
            /**
             * Modified
             * Format: date-time
             */
            modified: string;
            /** Size */
            size: number;
        };
        /**
         * NoteInfo
         * @description Summary info for a note in the vault.
         */
        NoteInfo: {
            /** Path */
            path: string;
            /** Name */
            name: string;
            /** Folder */
            folder: string;
            /**
             * Modified
             * Format: date-time
             */
            modified: string;
            /** Size */
            size: number;
            /** Title */
            title?: string | null;
            /**
             * Tags
             * @default []
             */
            tags: string[];
            /** Content Type */
            content_type?: string | null;
        };
        /**
         * NotesListResponse
         * @description Paginated list of notes.
         */
        NotesListResponse: {
            /** Notes */
            notes: components["schemas"]["NoteInfo"][];
            /** Total */
            total: number;
            /** Page */
            page: number;
            /** Page Size */
            page_size: number;
            /** Has More */
            has_more: boolean;
        };
        /**
         * PendingContentItem
         * @description A content item pending processing.
         */
        PendingContentItem: {
            /** Content Id */
            content_id: string;
            /** Title */
            title: string;
            /** Content Type */
            content_type: string;
            /** Status */
            status: string;
            /** Source Url */
            source_url?: string | null;
            /** Created At */
            created_at: string;
        };
        /**
         * PendingContentResponse
         * @description Response with list of pending content items.
         */
        PendingContentResponse: {
            /** Total */
            total: number;
            /** Items */
            items: components["schemas"]["PendingContentItem"][];
        };
        /**
         * PracticeHistoryDay
         * @description Single day of practice history for activity heatmap.
         *
         *     Contains practice activity metrics for one day, used to render
         *     GitHub-style activity heatmaps on the dashboard.
         */
        PracticeHistoryDay: {
            /**
             * Date
             * Format: date
             */
            date: string;
            /**
             * Count
             * @description Number of practice items completed
             * @default 0
             */
            count: number;
            /**
             * Minutes
             * @description Total practice minutes
             * @default 0
             */
            minutes: number;
            /**
             * Level
             * @description Activity level 0-4 for heatmap coloring
             * @default 0
             */
            level: number;
        };
        /**
         * PracticeHistoryResponse
         * @description Practice history for activity heatmap visualization.
         *
         *     Returns daily practice activity over a configurable time range,
         *     typically 26 or 52 weeks. Used to render a contribution-style
         *     heatmap showing practice consistency over time.
         */
        PracticeHistoryResponse: {
            /** Days */
            days?: components["schemas"]["PracticeHistoryDay"][];
            /**
             * Total Practice Days
             * @description Days with at least one practice
             * @default 0
             */
            total_practice_days: number;
            /**
             * Total Items
             * @description Total items practiced
             * @default 0
             */
            total_items: number;
            /**
             * Max Daily Count
             * @description Maximum items in a single day
             * @default 0
             */
            max_daily_count: number;
        };
        /**
         * ProcessingConfigRequest
         * @description Configuration options for processing request.
         */
        ProcessingConfigRequest: {
            /**
             * Generate Summaries
             * @default true
             */
            generate_summaries: boolean;
            /**
             * Extract Concepts
             * @default true
             */
            extract_concepts: boolean;
            /**
             * Assign Tags
             * @default true
             */
            assign_tags: boolean;
            /**
             * Generate Cards
             * @default true
             */
            generate_cards: boolean;
            /**
             * Discover Connections
             * @default true
             */
            discover_connections: boolean;
            /**
             * Generate Followups
             * @default true
             */
            generate_followups: boolean;
            /**
             * Generate Questions
             * @default true
             */
            generate_questions: boolean;
            /**
             * Create Obsidian Note
             * @default true
             */
            create_obsidian_note: boolean;
            /**
             * Create Neo4J Nodes
             * @default true
             */
            create_neo4j_nodes: boolean;
            /**
             * Validate Output
             * @default true
             */
            validate_output: boolean;
        };
        /**
         * ProcessingResultResponse
         * @description Response with full processing result.
         */
        ProcessingResultResponse: {
            /** Content Id */
            content_id: string;
            analysis: components["schemas"]["ContentAnalysis"];
            /** Summaries */
            summaries: {
                [key: string]: string;
            };
            extraction: components["schemas"]["ExtractionResult"];
            tags: components["schemas"]["TagAssignment"];
            /** Connections */
            connections: components["schemas"]["Connection"][];
            /** Followups */
            followups: components["schemas"]["FollowupTask"][];
            /** Questions */
            questions: components["schemas"]["MasteryQuestion"][];
            /** Obsidian Path */
            obsidian_path?: string | null;
            /** Neo4J Node Id */
            neo4j_node_id?: string | null;
            /** Processing Time Seconds */
            processing_time_seconds: number;
            /** Estimated Cost Usd */
            estimated_cost_usd: number;
        };
        /**
         * ProcessingStage
         * @description Processing pipeline stages that can be selectively run.
         * @enum {string}
         */
        ProcessingStage: "ANALYSIS" | "SUMMARIZATION" | "EXTRACTION" | "TAGGING" | "CONNECTIONS" | "FOLLOWUPS" | "QUESTIONS";
        /**
         * ProcessingStatusResponse
         * @description Response for processing status check.
         */
        ProcessingStatusResponse: {
            /** Status */
            status: string;
            /** Content Id */
            content_id: string;
            /** Started At */
            started_at?: string | null;
            /** Completed At */
            completed_at?: string | null;
            /** Processing Time Seconds */
            processing_time_seconds?: number | null;
            /** Estimated Cost Usd */
            estimated_cost_usd?: number | null;
            /** Error Message */
            error_message?: string | null;
        };
        /**
         * PromptSuggestion
         * @description A suggested prompt for the user.
         *
         *     Attributes:
         *         text: Suggested prompt text
         *         category: Category of the suggestion (e.g., "review", "explore", "learn")
         *         topic_id: Optional related topic ID
         */
        PromptSuggestion: {
            /** Text */
            text: string;
            /** Category */
            category: string;
            /** Topic Id */
            topic_id?: string | null;
        };
        /**
         * QuizQuestion
         * @description A single quiz question.
         *
         *     Attributes:
         *         id: Question unique identifier
         *         question: Question text
         *         options: Multiple choice options (if applicable)
         *         type: Question type
         */
        QuizQuestion: {
            /** Id */
            id: string;
            /** Question */
            question: string;
            /** Options */
            options?: string[] | null;
            /**
             * Type
             * @enum {string}
             */
            type: "multiple_choice" | "free_response";
        };
        /**
         * QuizRequest
         * @description Request to generate a quiz.
         *
         *     Attributes:
         *         topic_id: Topic ID to generate quiz for
         *         question_count: Number of questions to generate
         */
        QuizRequest: {
            /** Topic Id */
            topic_id: string;
            /**
             * Question Count
             * @default 5
             */
            question_count: number;
        };
        /**
         * QuizResponse
         * @description Generated quiz response.
         *
         *     Attributes:
         *         quiz_id: Unique identifier for this quiz
         *         topic: Topic name
         *         questions: List of quiz questions
         */
        QuizResponse: {
            /** Quiz Id */
            quiz_id: string;
            /** Topic */
            topic: string;
            /** Questions */
            questions: components["schemas"]["QuizQuestion"][];
        };
        /**
         * RaindropSyncRequest
         * @description Request body for Raindrop sync.
         */
        RaindropSyncRequest: {
            /**
             * Since Days
             * @default 1
             */
            since_days: number;
            /**
             * Collection Id
             * @default 0
             */
            collection_id: number | null;
            /** Limit */
            limit?: number | null;
        };
        /**
         * Rating
         * @description FSRS review ratings.
         *
         *     User self-assessment after reviewing a card or completing an exercise.
         *     Maps to FSRS algorithm parameters for scheduling.
         * @enum {integer}
         */
        Rating: 1 | 2 | 3 | 4;
        /**
         * RecommendationsResponse
         * @description Response containing study recommendations.
         *
         *     Attributes:
         *         recommendations: List of recommended topics
         */
        RecommendationsResponse: {
            /** Recommendations */
            recommendations: components["schemas"]["StudyRecommendation"][];
        };
        /**
         * RelatedConcept
         * @description A concept related to the explained topic.
         *
         *     Attributes:
         *         id: Concept ID
         *         name: Concept name
         */
        RelatedConcept: {
            /** Id */
            id: string;
            /** Name */
            name: string;
        };
        /**
         * ReviewForecast
         * @description Forecast of upcoming reviews.
         *
         *     Provides a breakdown of review workload to help users plan their study sessions.
         *     Overdue cards should be prioritized, while the weekly forecast helps set
         *     expectations for sustained learning commitment.
         */
        ReviewForecast: {
            /**
             * Overdue
             * @default 0
             */
            overdue: number;
            /**
             * Today
             * @default 0
             */
            today: number;
            /**
             * Tomorrow
             * @default 0
             */
            tomorrow: number;
            /**
             * This Week
             * @default 0
             */
            this_week: number;
            /**
             * Later
             * @default 0
             */
            later: number;
        };
        /**
         * SearchRequest
         * @description Search query parameters.
         *
         *     Configures semantic search across the knowledge graph
         *     with filtering and scoring options.
         *
         *     Attributes:
         *         query: Search query text (1-500 characters)
         *         node_types: Types to search (default: Content, Concept)
         *         limit: Maximum results to return (1-100, default: 20)
         *         min_score: Minimum relevance score threshold (0-1, default: 0.5)
         *         use_vector: Whether to use vector/embedding search when available
         */
        SearchRequest: {
            /** Query */
            query: string;
            /**
             * Node Types
             * @default [
             *       "Content",
             *       "Concept"
             *     ]
             */
            node_types: string[];
            /**
             * Limit
             * @default 20
             */
            limit: number;
            /**
             * Min Score
             * @default 0.5
             */
            min_score: number;
            /**
             * Use Vector
             * @description Use vector search when available
             * @default true
             */
            use_vector: boolean;
        };
        /**
         * SearchResponse
         * @description Search results response.
         *
         *     Contains ranked search results with query echo
         *     and performance metrics.
         *
         *     Attributes:
         *         query: Original search query
         *         results: List of matching results, ranked by score
         *         total: Total number of results returned
         *         search_time_ms: Search execution time in milliseconds
         */
        SearchResponse: {
            /** Query */
            query: string;
            /** Results */
            results: components["schemas"]["SearchResult"][];
            /** Total */
            total: number;
            /** Search Time Ms */
            search_time_ms: number;
        };
        /**
         * SearchResult
         * @description Single search result with relevance score.
         *
         *     Represents a matched node from semantic or keyword search
         *     with scoring and optional highlight snippets.
         *
         *     Attributes:
         *         id: Node identifier
         *         node_type: Type of matched node (Content, Concept, Note)
         *         title: Display title
         *         summary: Brief summary or excerpt
         *         score: Relevance score from 0.0 to 1.0
         *         highlights: Matching text snippets (for keyword search)
         */
        SearchResult: {
            /** Id */
            id: string;
            /** Node Type */
            node_type: string;
            /** Title */
            title: string;
            /** Summary */
            summary?: string | null;
            /** Score */
            score: number;
            /** Highlights */
            highlights?: string[];
        };
        /**
         * SessionCreateRequest
         * @description Request to create a practice session.
         *
         *     Creates a balanced session mixing due spaced rep cards (40%), weak spot exercises
         *     (30%), and new content (30%). The topic_filter focuses the session on a specific
         *     area, otherwise content is drawn from across all learned topics.
         *
         *     When reuse_exercises=True, existing exercises for the topic are used instead of
         *     generating new ones via LLM. This is faster and free (no API calls).
         */
        SessionCreateRequest: {
            /**
             * Duration Minutes
             * @description Target duration
             * @default 15
             */
            duration_minutes: number;
            /**
             * Topic Filter
             * @description Optional topic to focus on
             */
            topic_filter?: string | null;
            /** @default practice */
            session_type: components["schemas"]["SessionType"];
            /**
             * Reuse Exercises
             * @description Reuse existing exercises instead of generating new ones. Set to False to always generate fresh exercises via LLM.
             * @default true
             */
            reuse_exercises: boolean;
        };
        /**
         * SessionItem
         * @description Single item in a practice session (card or exercise).
         *
         *     Wraps either a spaced repetition card or an exercise with timing metadata.
         *     The session service interleaves these items for optimal learning, placing
         *     worked examples first (scaffolding) then shuffling remaining items (interleaving).
         */
        SessionItem: {
            /**
             * Item Type
             * @description 'card' or 'exercise'
             */
            item_type: string;
            card?: components["schemas"]["CardResponse"] | null;
            exercise?: components["schemas"]["ExerciseResponse"] | null;
            /**
             * Estimated Minutes
             * @default 2
             */
            estimated_minutes: number;
        };
        /**
         * SessionResponse
         * @description Practice session with items.
         *
         *     Contains the ordered list of items to complete during the session. Items are
         *     interleaved for optimal learning with worked examples placed first. The
         *     estimated duration helps users plan their available study time.
         */
        SessionResponse: {
            /** Session Id */
            session_id: number;
            /** Items */
            items: components["schemas"]["SessionItem"][];
            /** Estimated Duration Minutes */
            estimated_duration_minutes: number;
            /** Topics Covered */
            topics_covered: string[];
            session_type: components["schemas"]["SessionType"];
        };
        /**
         * SessionSummary
         * @description Summary after completing a session.
         *
         *     Provides performance metrics and mastery changes from the session. The
         *     mastery_changes dict shows how each practiced topic's mastery score changed,
         *     helping learners see the impact of their study session.
         */
        SessionSummary: {
            /** Session Id */
            session_id: number;
            /** Duration Minutes */
            duration_minutes: number;
            /** Cards Reviewed */
            cards_reviewed: number;
            /** Exercises Completed */
            exercises_completed: number;
            /** Correct Count */
            correct_count: number;
            /** Total Count */
            total_count: number;
            /** Average Score */
            average_score: number;
            /**
             * Mastery Changes
             * @description Topic -> mastery delta
             */
            mastery_changes?: {
                [key: string]: number;
            };
        };
        /**
         * SessionType
         * @description Types of practice sessions.
         * @enum {string}
         */
        SessionType: "review" | "practice" | "focused" | "weak_spots";
        /**
         * SourceReference
         * @description A source referenced by the assistant in its response.
         *
         *     Attributes:
         *         id: Content or concept ID
         *         title: Display title
         *         relevance: Relevance score (0-1)
         */
        SourceReference: {
            /** Id */
            id: string;
            /** Title */
            title: string;
            /** Relevance */
            relevance: number;
        };
        /**
         * StreakData
         * @description Practice streak information.
         *
         *     Tracks consecutive days of practice to motivate consistent learning habits.
         *     Includes current and longest streaks, milestone tracking, and weekly/monthly
         *     activity counts. Gamification element that encourages daily engagement.
         */
        StreakData: {
            /** Current Streak */
            current_streak: number;
            /** Longest Streak */
            longest_streak: number;
            /** Streak Start */
            streak_start?: string | null;
            /** Last Practice */
            last_practice?: string | null;
            /** Is Active Today */
            is_active_today: boolean;
            /** Days This Week */
            days_this_week: number;
            /** Days This Month */
            days_this_month: number;
            /** Milestones Reached */
            milestones_reached?: number[];
            /** Next Milestone */
            next_milestone?: number | null;
        };
        /**
         * StudyRecommendation
         * @description A personalized study recommendation.
         *
         *     Attributes:
         *         topic_id: ID of the recommended topic
         *         topic_name: Display name of the topic
         *         reason: Why this topic is recommended
         *         priority: Recommendation priority
         */
        StudyRecommendation: {
            /** Topic Id */
            topic_id: string;
            /** Topic Name */
            topic_name: string;
            /** Reason */
            reason: string;
            /**
             * Priority
             * @enum {string}
             */
            priority: "high" | "medium" | "low";
        };
        /**
         * SuggestionsResponse
         * @description Response containing prompt suggestions.
         *
         *     Attributes:
         *         suggestions: List of suggested prompts
         */
        SuggestionsResponse: {
            /** Suggestions */
            suggestions: components["schemas"]["PromptSuggestion"][];
        };
        /**
         * TagAssignment
         * @description Result of tag classification stage.
         *
         *     Tags are assigned from a controlled vocabulary (tag taxonomy) to ensure
         *     consistency across the knowledge base. Tags enable filtering, grouping,
         *     and discovering content by domain, status, or quality level.
         *
         *     Attributes:
         *         domain_tags: Tags from the domain taxonomy (e.g., ml/transformers/attention)
         *         meta_tags: Status and quality tags (e.g., status/actionable, quality/deep-dive)
         *         suggested_new_tags: Tags suggested if taxonomy has gaps
         *         reasoning: Brief explanation of tag choices
         */
        TagAssignment: {
            /** Domain Tags */
            domain_tags?: string[];
            /** Meta Tags */
            meta_tags?: string[];
            /** Suggested New Tags */
            suggested_new_tags?: string[];
            /**
             * Reasoning
             * @default
             */
            reasoning: string;
        };
        /**
         * TimeInvestmentPeriod
         * @description Time investment for a specific period.
         *
         *     Represents aggregated learning time within a time window, broken down by topic
         *     and activity type. Used for building time-series visualizations of study habits.
         */
        TimeInvestmentPeriod: {
            /**
             * Period Start
             * Format: date-time
             */
            period_start: string;
            /**
             * Period End
             * Format: date-time
             */
            period_end: string;
            /** Total Minutes */
            total_minutes: number;
            /** By Topic */
            by_topic?: {
                [key: string]: number;
            };
            /** By Activity */
            by_activity?: {
                [key: string]: number;
            };
        };
        /**
         * TimeInvestmentResponse
         * @description Time investment summary response.
         *
         *     Provides comprehensive time tracking data including period breakdowns, top topics
         *     by time spent, daily average, and trend analysis. Powers the time investment
         *     dashboard for understanding study patterns and consistency.
         */
        TimeInvestmentResponse: {
            /** Total Minutes */
            total_minutes: number;
            /** Periods */
            periods: components["schemas"]["TimeInvestmentPeriod"][];
            /** Top Topics */
            top_topics?: [
                string,
                number
            ][];
            /** Daily Average */
            daily_average: number;
            /** Trend */
            trend: string;
        };
        /**
         * TimePeriod
         * @description Time periods for analytics queries.
         *
         *     Used by time investment and other analytics endpoints to specify
         *     the date range for data aggregation.
         * @enum {string}
         */
        TimePeriod: "7d" | "30d" | "90d" | "1y" | "all";
        /**
         * TopicHierarchyResponse
         * @description Full topic hierarchy response.
         *
         *     Returns the complete topic tree for navigation
         *     with aggregate statistics.
         *
         *     Attributes:
         *         roots: Root-level topic nodes
         *         total_topics: Total number of topics in the tree
         *         max_depth: Maximum depth of the tree
         */
        TopicHierarchyResponse: {
            /** Roots */
            roots: components["schemas"]["TopicNode"][];
            /** Total Topics */
            total_topics: number;
            /** Max Depth */
            max_depth: number;
        };
        /**
         * TopicNode
         * @description A node in the topic hierarchy tree.
         *
         *     Topics are organized hierarchically using slash-separated paths
         *     (e.g., "ml/deep-learning/transformers"). This model supports
         *     recursive tree structures for navigation UIs.
         *
         *     Attributes:
         *         path: Full topic path (e.g., "ml/deep-learning/transformers")
         *         name: Leaf name (e.g., "transformers")
         *         depth: Depth in tree (0 = root)
         *         content_count: Number of content items with this topic
         *         children: Child topic nodes
         *         mastery_score: Optional mastery score if user has learning data
         */
        TopicNode: {
            /** Path */
            path: string;
            /** Name */
            name: string;
            /** Depth */
            depth: number;
            /** Content Count */
            content_count: number;
            /** Children */
            children?: components["schemas"]["TopicNode"][];
            /**
             * Mastery Score
             * @description User mastery score for this topic
             */
            mastery_score?: number | null;
        };
        /**
         * TriggerProcessingRequest
         * @description Request body for triggering processing.
         */
        TriggerProcessingRequest: {
            /**
             * Content Id
             * @description UUID of content to process
             */
            content_id: string;
            config?: components["schemas"]["ProcessingConfigRequest"] | null;
        };
        /**
         * TriggerProcessingResponse
         * @description Response for processing trigger.
         */
        TriggerProcessingResponse: {
            /** Status */
            status: string;
            /** Content Id */
            content_id: string;
            /** Message */
            message: string;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * WeakSpot
         * @description Topic identified as needing attention.
         *
         *     Flagged when mastery score falls below threshold or shows declining trend.
         *     Includes actionable recommendations and suggested exercise types tailored
         *     to the learner's current level (e.g., worked examples for novices).
         */
        WeakSpot: {
            /** Topic */
            topic: string;
            /** Mastery Score */
            mastery_score: number;
            /** Success Rate */
            success_rate?: number | null;
            trend: components["schemas"]["MasteryTrend"];
            /**
             * Recommendation
             * @description Suggested action
             */
            recommendation: string;
            /** Suggested Exercise Types */
            suggested_exercise_types?: components["schemas"]["ExerciseType"][];
        };
        /**
         * WeakSpotsResponse
         * @description Response with weak spots.
         *
         *     Returns topics sorted by priority: declining trends first, then lowest mastery.
         *     The threshold (default 0.6) determines what qualifies as a weak spot, helping
         *     learners focus their limited study time on areas that need the most work.
         */
        WeakSpotsResponse: {
            /** Weak Spots */
            weak_spots: components["schemas"]["WeakSpot"][];
            /** Total Topics */
            total_topics: number;
            /**
             * Weak Spot Threshold
             * @default 0.6
             */
            weak_spot_threshold: number;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    health_check_api_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    detailed_health_check_api_health_detailed_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    readiness_check_api_health_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    capture_text_api_capture_text_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_capture_text_api_capture_text_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    capture_url_api_capture_url_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_capture_url_api_capture_url_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    capture_photo_api_capture_photo_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_capture_photo_api_capture_photo_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    capture_voice_api_capture_voice_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_capture_voice_api_capture_voice_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    capture_pdf_api_capture_pdf_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_capture_pdf_api_capture_pdf_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    capture_book_api_capture_book_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Body_capture_book_api_capture_book_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    trigger_raindrop_sync_api_ingestion_raindrop_sync_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RaindropSyncRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    trigger_github_sync_api_ingestion_github_sync_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GitHubSyncRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_processing_status_api_ingestion_status__content_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                content_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_queue_statistics_api_ingestion_queue_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    list_scheduled_jobs_api_ingestion_scheduled_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    trigger_scheduled_job_api_ingestion_scheduled__job_id__trigger_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_pending_content_api_ingestion_pending_get: {
        parameters: {
            query?: {
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    sync_taxonomy_api_ingestion_taxonomy_sync_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    trigger_processing_api_processing_trigger_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TriggerProcessingRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TriggerProcessingResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_processing_status_api_processing_status__content_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                content_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessingStatusResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_processing_result_api_processing_result__content_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                content_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessingResultResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_pending_content_api_processing_pending_get: {
        parameters: {
            query?: {
                limit?: number;
                include_failed?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PendingContentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reprocess_content_api_processing_reprocess_post: {
        parameters: {
            query: {
                content_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ProcessingStage"][] | null;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_vault_status_api_vault_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    ensure_vault_structure_api_vault_ensure_structure_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    regenerate_indices_api_vault_indices_regenerate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    create_daily_note_api_vault_daily_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DailyNoteRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_inbox_item_api_vault_daily_inbox_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["InboxItemRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    sync_vault_to_neo4j_api_vault_sync_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    list_folders_api_vault_folders_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_vault_watcher_status_api_vault_watcher_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    get_vault_sync_status_api_vault_sync_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    list_notes_api_vault_notes_get: {
        parameters: {
            query?: {
                /** @description Filter by folder path */
                folder?: string | null;
                /** @description Search in file names */
                search?: string | null;
                /** @description Filter by tag */
                tag?: string | null;
                /** @description Filter by content type */
                content_type?: string | null;
                /** @description Page number */
                page?: number;
                /** @description Notes per page */
                page_size?: number;
                /** @description Sort by: modified, name, size */
                sort_by?: string;
                /** @description Sort descending */
                sort_desc?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotesListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_note_api_vault_notes__note_path__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                note_path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteContent"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_graph_visualization_api_knowledge_graph_get: {
        parameters: {
            query?: {
                /** @description Center graph on this node ID */
                center_id?: string | null;
                /** @description Comma-separated node types */
                node_types?: string;
                /** @description Traversal depth from center */
                depth?: number;
                /** @description Max nodes to return */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GraphResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_graph_stats_api_knowledge_stats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GraphStats"];
                };
            };
        };
    };
    get_node_details_api_knowledge_node__node_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeDetails"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    knowledge_graph_health_api_knowledge_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    search_knowledge_api_knowledge_search_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SearchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_connections_api_knowledge_connections__node_id__get: {
        parameters: {
            query?: {
                /** @description Filter by direction */
                direction?: components["schemas"]["ConnectionDirection"];
                /** @description Max connections per direction */
                limit?: number;
            };
            header?: never;
            path: {
                node_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConnectionsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_topic_hierarchy_api_knowledge_topics_get: {
        parameters: {
            query?: {
                /** @description Min content count to include */
                min_content?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopicHierarchyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_session_api_practice_session_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SessionCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SessionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    end_session_api_practice_session__session_id__end_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                session_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SessionSummary"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    generate_exercise_api_practice_exercise_generate_post: {
        parameters: {
            query?: {
                /** @description Current mastery level */
                mastery_level?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExerciseGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExerciseResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_exercises_api_practice_exercises_get: {
        parameters: {
            query?: {
                /** @description Filter by topic path */
                topic?: string | null;
                /** @description Filter by exercise type */
                exercise_type?: components["schemas"]["ExerciseType"] | null;
                /** @description Filter by difficulty */
                difficulty?: components["schemas"]["ExerciseDifficulty"] | null;
                /** @description Maximum exercises to return */
                limit?: number;
                /** @description Offset for pagination */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExerciseResponse"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_exercise_api_practice_exercise__exercise_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                exercise_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExerciseResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    submit_attempt_api_practice_submit_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AttemptSubmitRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AttemptEvaluationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_confidence_api_practice_attempt__attempt_id__confidence_patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                attempt_id: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AttemptConfidenceUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_card_api_review_cards_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CardCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CardResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_card_api_review_cards__card_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                card_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CardResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_due_cards_api_review_due_get: {
        parameters: {
            query?: {
                /** @description Maximum cards to return */
                limit?: number;
                /** @description Filter by topic tag */
                topic?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DueCardsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    rate_card_api_review_rate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CardReviewRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CardReviewResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    evaluate_card_answer_api_review_evaluate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CardEvaluateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CardEvaluateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_card_stats_api_review_stats_get: {
        parameters: {
            query?: {
                /** @description Filter by topic tag */
                topic?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CardStats"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    generate_cards_api_review_generate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CardGenerationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CardGenerationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    ensure_cards_for_topic_api_review_ensure_cards_post: {
        parameters: {
            query: {
                /** @description Topic path */
                topic: string;
                /** @description Minimum cards required */
                minimum?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CardGenerationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_mastery_overview_api_analytics_overview_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MasteryOverview"];
                };
            };
        };
    };
    get_daily_stats_api_analytics_daily_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DailyStatsResponse"];
                };
            };
        };
    };
    get_practice_history_api_analytics_practice_history_get: {
        parameters: {
            query?: {
                /** @description Number of weeks of history */
                weeks?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PracticeHistoryResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_topic_mastery_api_analytics_mastery__topic__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                topic: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MasteryState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_weak_spots_api_analytics_weak_spots_get: {
        parameters: {
            query?: {
                /** @description Maximum weak spots to return */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WeakSpotsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_learning_curve_api_analytics_learning_curve_get: {
        parameters: {
            query?: {
                /** @description Topic to get curve for (None for overall) */
                topic?: string | null;
                /** @description Number of days of history */
                days?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LearningCurveResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    take_mastery_snapshot_api_analytics_snapshot_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    get_time_investment_api_analytics_time_investment_get: {
        parameters: {
            query?: {
                /** @description Time period to analyze */
                period?: components["schemas"]["TimePeriod"];
                /** @description How to group the data */
                group_by?: components["schemas"]["GroupBy"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TimeInvestmentResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_streak_data_api_analytics_streak_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreakData"];
                };
            };
        };
    };
    log_learning_time_api_analytics_time_log_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LogTimeRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogTimeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    send_message_api_assistant_chat_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChatRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChatResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_conversations_api_assistant_conversations_get: {
        parameters: {
            query?: {
                /** @description Max conversations to return */
                limit?: number;
                /** @description Number to skip for pagination */
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_all_conversations_api_assistant_conversations_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
        };
    };
    get_conversation_api_assistant_conversations__conversation_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversation_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationDetail"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_conversation_api_assistant_conversations__conversation_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversation_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    rename_conversation_api_assistant_conversations__conversation_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversation_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConversationUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationUpdateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_conversation_messages_api_assistant_conversations__conversation_id__messages_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                conversation_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeleteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_suggestions_api_assistant_suggestions_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuggestionsResponse"];
                };
            };
        };
    };
    search_knowledge_api_assistant_search_get: {
        parameters: {
            query: {
                /** @description Search query */
                q: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KnowledgeSearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_recommendations_api_assistant_recommendations_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecommendationsResponse"];
                };
            };
        };
    };
    generate_quiz_api_assistant_quiz_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QuizRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuizResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    explain_concept_api_assistant_explain__concept_id__get: {
        parameters: {
            query?: {
                /** @description Explanation style: 'simple', 'detailed', or 'eli5' */
                style?: components["schemas"]["ExplanationStyle"];
            };
            header?: never;
            path: {
                concept_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExplanationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    graph_graph_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    root__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
